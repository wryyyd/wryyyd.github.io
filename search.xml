<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>P1542题解</title>
    <url>/posts/84e5ff3c/</url>
    <content><![CDATA[<p> 这道题在于找到一个最小的速度，通过这个速度能够满足要求的跑完全程。可以直接二分速度来设置上限，对于速度可以小的路径段，早到了位置可以进行等待。故正确性可以保证。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> ti;</span><br><span class="line"><span class="type">int</span> x[MAXN], y[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">double</span> v)</span> </span>&#123;</span><br><span class="line">    ti = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ti += (<span class="type">long</span> <span class="type">double</span>)s[i] / v;</span><br><span class="line">        <span class="keyword">if</span> (ti &gt; y[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ti &lt; x[i]) ti = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x[i], &amp;y[i], &amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> l = <span class="number">0.0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid - <span class="number">1e-7</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1e-7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2Lf\n&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>P1247题解</title>
    <url>/posts/b2bcbd52/</url>
    <content><![CDATA[<p> 对于取火柴的题目，就是取石子即Nim均衡，如果每个堆的大小异或起来为0，那么此时必输，那么找必胜策略的方法为对于其中一个堆，取出石子使得剩下的石子的个数等于其余堆的异或和。
<span id="more"></span> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> k, a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) tmp = tmp ^ a[i];</span><br><span class="line">    <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lose\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i] ^ tmp;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; a[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a[i] - x, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>博弈论</tag>
        <tag>NIM均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>P1972题解</title>
    <url>/posts/ec5e0bcb/</url>
    <content><![CDATA[<p> 这道题需要明确的是，查询的是种类个数，故多个相同种类的点带来的贡献只有一个有效。假设只有最右端有效，那么从左到右依次更改，出现一个新的种类时，删去原来位置上的贡献，更新当前位置上的贡献。更改到第
i个的时候，那么对于这个区间，可以采用前缀和的方式求得所有的右区间为i的查询的结果，因为假设一个类别出现在L左侧和右侧，那么根据更新规则，一定是在L右侧的点产生贡献，保证不漏，不出现在L右侧的点，不会在<span
class="math inline">\([L,R]\)</span>之间产生贡献。采用区间查询的方式，一次性告诉所有查询，可以采用离线查询后返回的方式得到答案。故采用每个区间最右侧作为排序基准。每次修改的只是一个点，只用枚举完整个序列，为<span
class="math inline">\(\Theta(n)\)</span></p>
<p> 整个过程区间查询，单点修改，为了保证其效率的优秀，采用的是树状数组对整个数组进行操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rg register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">queryy</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> queryy &amp;q) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; q.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, a[MAXN], tree[MAXN], last[MAXN], ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fread</span><span class="params">(<span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch) &amp;&amp; ch ^ <span class="string">&#x27;-&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rg i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        tree[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (rg i = x; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        res += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fread</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (rg i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">fread</span>(a[i]);</span><br><span class="line">    <span class="built_in">fread</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (rg i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">fread</span>(q[i].l);</span><br><span class="line">        <span class="built_in">fread</span>(q[i].r);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> lastr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (rg i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (rg j = lastr; j &lt;= q[i].r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last[a[j]]) <span class="built_in">modify</span>(last[a[j]], <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">modify</span>(j, <span class="number">1</span>);</span><br><span class="line">            last[a[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        lastr = q[i].r;</span><br><span class="line">        ans[q[i].id] = <span class="built_in">query</span>(q[i].r) - <span class="built_in">query</span>(q[i].l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rg i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
        <tag>前缀和</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>P2157题解</title>
    <url>/posts/acac3a0a/</url>
    <content><![CDATA[<p>​ 当前是否选择第<span
class="math inline">\(i\)</span>个人取吃饭受到他之前的人和他之后的人影响，不符合无后效性的定义，而他之后的人根据题目要求最多只有8个，可以考虑使用状态压缩，把第<span
class="math inline">\(i\)</span>个人和其后面7个人是否吃饭作为状态进行压缩，故DP的一个维度为状态，大小为256。</p>
<p>​ 不妨取第一维<span class="math inline">\(i\)</span>表示前<span
class="math inline">\(i\)</span>-1个人都吃完成，第二维<span
class="math inline">\(j\)</span>表示第<span
class="math inline">\(i\)</span>个人和他后面7个人是否吃饭的状态，采用小端表示，即表示第<span
class="math inline">\(i\)</span>个人的二进制位为最低位（主要是方便）。</p>
<p>​ 因为更新权值需要知道上一个吃饭的是谁，故需要第三维表示上一个吃饭的是谁，为了保证全局最优解，故需要记录状态，而非仅记录当前产生贡献（最大值）中选取的上一个吃饭的是谁，虽然第1维表示前面<span
class="math inline">\(i\)</span>-1个人吃了饭，但是前面的人吃饭顺序不确定，所以这一维度需要表示的范围从第<span
class="math inline">\(i\)</span>个人的前到第<span
class="math inline">\(i\)</span>个人的后。而最大的容忍插队是8个，故如果当前要选择第<span
class="math inline">\(i\)</span>个人吃饭，那么必然上一个吃饭的人的范围在第<span
class="math inline">\(i\)</span>个人前8个之间，否则不符合仅允许后<span
class="math inline">\(B_i\)</span>个人吃饭的要求。故第三维的范围为<span
class="math inline">\([-8,7]\)</span>，为了使得数组下标不为负，那么可以修改范围为<span
class="math inline">\([0,15]\)</span></p>
<p>​ 故可以把DP方程写为 <span class="math display">\[
f[i][j][k]
\]</span>
​ 那么对于DP方程的转移，首先如何转移第一维的值。根据第一维的规则，<span
class="math inline">\(i\)</span>表示前<span
class="math inline">\(i\)</span>-1个人吃完饭，可知如果第<span
class="math inline">\(i\)</span>个人吃完饭了，就可以进行转移，即<span
class="math inline">\(j\)</span>的最低位为1时，就可以转移了，所以转移的规则为
<span class="math display">\[
f[i+1][j&gt;&gt;1][k-1] = min(f[i+1][j&gt;&gt;1][k-1],f[i][j][k])\quad
(j\&amp;1==1)
\]</span> ​ 在这种情况下，<span
class="math inline">\(f[i+1][j&gt;&gt;1][k-1]\)</span>与<span
class="math inline">\(f[i][j][k]\)</span>等价，故优先转移第一维，使用<span
class="math inline">\(f[i+1][j&gt;&gt;1][k-1]\)</span>对于后续的情况进行更新，减少了第一维转移的个数。</p>
<p>​ 对于<span
class="math inline">\(j\)</span>最后一位不为1的情况，可以枚举当前吃饭的是谁，即选择<span
class="math inline">\(j\)</span>中二进制位为0的位置，让这个位置的人吃饭，那么更新规则为
<span class="math display">\[
f[i][j|(1&lt;&lt;z)][k] =
min(f[i][j|(1&lt;&lt;z)][k],f[i][j][k]+T[i+z]\oplus T[i+k])\quad
(j\&amp;1!=1)
\]</span> ​ 那么<span
class="math inline">\(i+z\)</span>上的人能否吃饭受到第<span
class="math inline">\(i\)</span>个人容许的限度和<span
class="math inline">\([i+1,i+z-1]\)</span>之间没有吃饭的人的容许限度的限制。即<span
class="math inline">\(z\)</span>的选择大小需要考虑他到<span
class="math inline">\(i\)</span>之间没有吃饭的人的容许情况。（这一点不考虑完整只考虑i的容许的话只有32%的正确）。</p>
<p>​ 在更新时，还需要考虑是否是第一个人，第一个人不计算时间。</p>
<p>​ 根据上式转移方程，那么初始值可以选择为 <span class="math display">\[
f[1][0][7]=0
\]</span>
表示当前进行到第一个人，当前状态是0，上一个吃饭的人设置为第0个人，表示不存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> C;</span><br><span class="line"><span class="type">int</span> T[MAXN], B[MAXN], f[MAXN][<span class="number">300</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettime</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T[i] ^ T[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;C);</span><br><span class="line">    <span class="keyword">while</span> (C--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;T[i], &amp;B[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++)</span><br><span class="line">                    f[i][j][k] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-8</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f[i][j][k + <span class="number">8</span>] != <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                            f[i + <span class="number">1</span>][j &gt;&gt; <span class="number">1</span>][k + <span class="number">7</span>] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][j &gt;&gt; <span class="number">1</span>][k + <span class="number">7</span>], f[i][j][k + <span class="number">8</span>]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">int</span> limitb = <span class="built_in">min</span>(i + B[i], n);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; i + z &lt;= limitb; z++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!((j &gt;&gt; z) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                                    f[i][j | (<span class="number">1</span> &lt;&lt; z)][z + <span class="number">8</span>] = <span class="built_in">min</span>(f[i][j | (<span class="number">1</span> &lt;&lt; z)][z + <span class="number">8</span>], f[i][j][k + <span class="number">8</span>] + ((i + k) ? <span class="built_in">gettime</span>(i + k, i + z) : <span class="number">0</span>));</span><br><span class="line">                                    limitb = <span class="built_in">min</span>(limitb, i + z + B[i + z]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-8</span>; k &lt; <span class="number">0</span>; k++) ans = <span class="built_in">min</span>(ans, f[n + <span class="number">1</span>][<span class="number">0</span>][k + <span class="number">8</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>P2254题解</title>
    <url>/posts/a4c91c52/</url>
    <content><![CDATA[<p> 题面中的魔法的含义是1900在该时间段的最大滑动距离是时间段的长度，并不关心具体在哪个位置时使用了魔法使得1900暂停（题目没问，且对于一条可行的路径，其使用魔法的可行选项并不唯一）。</p>
<p> 故可以不按照时间进行枚举，而是对于时间段进行枚举，（减少必须枚举的数量），将一个时间段内依次枚举改为找到一个时间段内可能对于当前点产生贡献的点并找到其中的最大值</p>
<p> 那么对于第<span class="math inline">\(i\)</span>个时间段<span
class="math inline">\([s_i,t_i]\)</span>，对于当前点<span
class="math inline">\((x,y)\)</span>处，其到达这个位置可能的最大路径长度由逆着滑动方向，滑动距离不超过时间段长度，且滑动过程中没有障碍物的情况下能够到达的点的集合中，之前的路径长度加上第<span
class="math inline">\(i\)</span>个时间段内需要移动的滑动距离最大的点提供。</p>
<p> 不妨设状态为<span
class="math inline">\(f[k][x][y]\)</span>，表示当前在第<span
class="math inline">\(k\)</span>个时间段到达点<span
class="math inline">\((x,y)\)</span>时能够获得的最大路径，那么可以根据上面的分析将状态转移方程写为
<span class="math display">\[
f[k][x][y] =
max(f[k][x][y],f[k-1][x+t*d[x]][y+t*d[y]]+t*(abs(d[x])+abs(d[y])))
\]</span> 转移条件为 <span class="math display">\[
s_i\leq t\leq t_i \quad 且 \quad (x+t*d[x],y+t*d[y])到(x,y)之间无障碍物
\]</span> 此时的时间复杂度可以知道为<span
class="math inline">\(\Theta(KNMN)\)</span>，其中<span
class="math inline">\(K\)</span>来自枚举时间段，<span
class="math inline">\(NM\)</span>来自枚举图中每一个点，<span
class="math inline">\(N\)</span>来自对于每一个点去找到他的最大值，当<span
class="math inline">\(K,N,M\)</span>取200时，时间复杂度来到<span
class="math inline">\(1.6\times10^9\)</span>，如果计算上常数，其复杂度难以接受。</p>
<p> 对于一个时间段内进行更新的话，可以发现其中对于每个点来说，其需要向前找的距离一致，那么就是一个滑动窗口，可以采用单调队列进行优化。此时找的是最大值，那么维护的是一个单调递减队列。单调队列保证其内容递减，当一个新的值入队，那么从后向前删除队中比他小的值，这些值在之后的更新中将不会有机会产生贡献，并将这个值插入队尾。接着从头开始枚举，删除不在窗口中的值。</p>
<p> 对于这道题来说，每次移动的方向是确定的，假设向下移动，那么对于每一个列来说其是相互独立的，不会相互影响，可以从上到下依次更新。对于每一列，采用一个单调队列，设当前为时间段<span
class="math inline">\(k\)</span>，那么将<span
class="math inline">\(k-1\)</span>时间段中在位置<span
class="math inline">\((x,y)\)</span>的<span
class="math inline">\(f\)</span>值取出，放入单调队列并维护这个单调队列合法，注意此时单调队列的大小判断方式为对应位置的上一时刻<span
class="math inline">\(f\)</span>值加上在这一时刻移动的距离，之后用单调队列的队首即最大贡献更新。如果遇到了障碍，说明障碍前的点不会更新障碍后的点，那么可以将队列清空，那么此时通过势能分析法，每个点都只会被枚举一次，那么消去了循环最内层带来枚举最大值的时间复杂度，整体时间复杂度变为<span
class="math inline">\(\Theta(KNM)\)</span>，空间复杂度同样为<span
class="math inline">\(\Theta(KNM)\)</span>，由于更新方程只与上一个时刻有关，可以将第一维优化为只有0，1两个值，或者直接消去第一维。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 205</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N, M, K, X, Y, s, t, d;</span><br><span class="line"><span class="type">char</span> ch[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, flag;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x1 - x2) + <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    deque&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= N &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= M; i++, x += dx[d], y += dy[d]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[x][y] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">            q.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[x][y][flag] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">back</span>().val + <span class="built_in">dist</span>(q.<span class="built_in">back</span>().x, q.<span class="built_in">back</span>().y, x, y) &lt;= dp[x][y][flag]) &#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>((node)&#123;x, y, dp[x][y][flag]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">dist</span>(q.<span class="built_in">front</span>().x, q.<span class="built_in">front</span>().y, x, y) &gt; len) &#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            dp[x][y][flag ^ <span class="number">1</span>] = <span class="built_in">max</span>(dp[x][y][flag ^ <span class="number">1</span>], q.<span class="built_in">front</span>().val + <span class="built_in">dist</span>(q.<span class="built_in">front</span>().x, q.<span class="built_in">front</span>().y, x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;N, &amp;M, &amp;X, &amp;Y, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[X][Y][flag] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;d);</span><br><span class="line">        <span class="type">int</span> len = t - s + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">                    <span class="built_in">modify</span>(d, N, i, len);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">                    <span class="built_in">modify</span>(d, <span class="number">1</span>, i, len);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">                    <span class="built_in">modify</span>(d, i, M, len);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">                    <span class="built_in">modify</span>(d, i, <span class="number">1</span>, len);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i][j][flag]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>P2607题解</title>
    <url>/posts/802d59a7/</url>
    <content><![CDATA[<p> 对于这道题，可以明确的是，这道题和没有上司的舞会是一致的（升级版）。这道题的改变在于，这个图中会出现简单的环，且这个环不会出现环中环的情况，故可以不去找桥，而是直接把这个环中选择一条边，强制删去，然后剩余的连通块可以看作一颗树，与没有上司的舞会是一样的。而对于整个连通块答案的统计可以选择被删去边两侧的点，依次枚举两者不被选择的情况。（保证不会冲突，如果枚举两个点被选取的情况，因为DP的无后效性，会出现A点被选取，但是B点因为一条边被删去，故同样的被选取的情况。）（只枚举不被选取的情况的正确性还可以有A，B中有边相连，可能出现的情况只有三种，（选A）（选B）（A，B都不要））</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> next,to;</span><br><span class="line">&#125;e[<span class="number">2</span>*MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN],cnt,val[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN],n;</span><br><span class="line"><span class="type">int</span> S,T,cut_edge[<span class="number">2</span>*MAXN],flag;</span><br><span class="line">LL f[MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d\n&quot;,u,v);</span></span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            S=u;T=v;</span><br><span class="line">            cut_edge[i]=cut_edge[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>]=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> to=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa||cut_edge[i]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getans</span>(to,u);</span><br><span class="line">        f[u][<span class="number">0</span>]+=(LL)<span class="built_in">max</span>(f[to][<span class="number">0</span>],f[to][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>]+=(LL)f[to][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;val[i],&amp;tmp);</span><br><span class="line">        <span class="built_in">addedge</span>(i,tmp);</span><br><span class="line">        <span class="built_in">addedge</span>(tmp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">getans</span>(S,<span class="number">0</span>);</span><br><span class="line">        LL temp = f[S][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">getans</span>(T,<span class="number">0</span>);</span><br><span class="line">        temp = <span class="built_in">max</span>(temp,f[T][<span class="number">0</span>]);</span><br><span class="line">        ans += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
        <tag>环</tag>
      </tags>
  </entry>
  <entry>
    <title>P2742题解</title>
    <url>/posts/41246cb9/</url>
    <content><![CDATA[<h2 id="暴力">暴力</h2>
<p> 对于求凸包的题，暴力的方法，从最左下的点开始，旋转一条边，找所有的点中最早与这条边重合的，这样做时间复杂度为<span
class="math inline">\(\Theta(nm)\)</span></p>
<h2 id="graham">Graham</h2>
<p> 考虑优化枚举顺序，使得每次不用重新判断每个点是否出现在这条线上，可以发现，一个凸包从左下角开始，逆时针依次枚举，路径上的点与左下角组成的直线角度逐渐增大，可以在选取了左下点后，以左下角与其他点组成的向量的角度大小作为排序基准，进行排序，以排序后的顺序作为枚举顺序。</p>
<p> 使用一个栈存下路径上的点，对于新进入的点<span
class="math inline">\(C\)</span>，假设此时栈顶的元素为<span
class="math inline">\(A\)</span>，栈顶下一个点为<span
class="math inline">\(B\)</span>，点<span
class="math inline">\(C\)</span>此时一定进入栈中，但是点<span
class="math inline">\(A\)</span>是否出栈，即点<span
class="math inline">\(A\)</span>是否在<span
class="math inline">\(CB\)</span>的连线之内，若在，那么<span
class="math inline">\(A\)</span>显然不再路径上，<span
class="math inline">\(A\)</span>出栈。下图是一个<span
class="math inline">\(A\)</span>在<span
class="math inline">\(CB\)</span>内的示意图。</p>
<figure>
<img src="image.png" alt="A在图中" />
<figcaption aria-hidden="true">A在图中</figcaption>
</figure>
<p>对于上面的情况，判断是否在凸包内可以采用向量叉乘，通过向量叉乘的<span
class="math inline">\(z\)</span>维的正负判断。叉乘计算方式为</p>
<p><span class="math display">\[
\begin{align*}
    \vec{a} \times \vec{b} &amp;= \left| \begin{matrix}
    \vec{i} &amp; \vec{j} &amp; \vec{k} \\
    \hline
    a_i &amp; a_j &amp; a_k\\
    b_i &amp; b_j &amp; b_k
\end{matrix}\right| \\
    &amp;= (a_j\cdot b_k-a_k\cdot b_j,-(a_i\cdot b_k-a_k\cdot
b_i),a_i\cdot b_j-a_j\cdot b_i)
\end{align*}
\]</span></p>
<p> 当<span class="math inline">\(z\)</span>轴均取0时，只保留值<span
class="math inline">\(a_i\cdot b_j-a_j\cdot b_i\)</span>，当<span
class="math inline">\(\vec{a}\)</span>沿逆时针方向转向<span
class="math inline">\(\vec{b}\)</span>时，<span
class="math inline">\(a_i\cdot b_j-a_j\cdot b_i &gt;
0\)</span>，可以由极坐标证明这个关系。</p>
<p> 那么判断条件变成计算<span
class="math inline">\(\vec{CA}\times\vec{CB}\)</span>，若值大于0，则证明点<span
class="math inline">\(A\)</span>需要出栈，若值等于0，则证明<span
class="math inline">\(\vec{CA}\)</span>和<span
class="math inline">\(\vec{CB}\)</span>共线，选择长度最长的那条边，才保证符合凸包的条件。</p>
<p> 需要注意这个过程需要一直进行，直到找到一个<span
class="math inline">\(\vec{CA}\)</span>和<span
class="math inline">\(\vec{CB}&lt;0\)</span>的点，再把点<span
class="math inline">\(C\)</span>插入栈中。</p>
<p> 最后得到答案需要加上栈中最后一个点到起始点的距离。</p>
<p> 排序效率为<span class="math inline">\(\Theta(n\log
n)\)</span>，扫描过程效率为<span
class="math inline">\(\Theta(n)\)</span></p>
<h2 id="andrew">Andrew</h2>
<p> Andrew算法使用不同的排序方法，按照<span
class="math inline">\(x\)</span>轴坐标的大小排序，判断过程一致，需要注意，Andrew算法从左到右只能枚举凸包的一半，还需要从结束点枚举回开始点。注意第二次枚举的时候通过栈记录路径时，出栈不能把前一半凸包（在上述枚举条件下，为下凸包）的路径清理掉。</p>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3377题解</title>
    <url>/posts/2fbd7ecf/</url>
    <content><![CDATA[<p> 这是一个基本的左偏树(可并堆)的模板，左偏树就是定义了距离<span
class="math inline">\(dist\)</span>，要求左子树的<span
class="math inline">\(dist\)</span>大于右子树的<span
class="math inline">\(dist\)</span>， <span
class="math inline">\(dist\)</span>定义为根到外点的距离，外点定义为一个子树的点，计算方式为边权之和，（可为层高差）</p>
<p> 并查集中对于根节点的删除，在给根节点删除之后，把根节点的父亲数组指向他的子节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lc, rc, dist, fa, val;</span><br><span class="line">&#125; tree[MAXN];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">合并操作</span></span><br><span class="line"><span class="comment">要求左子树的距离权值dist大于右子树的距离权值dist</span></span><br><span class="line"><span class="comment">当前树本身的权值dist大小记作右子树的权值+1</span></span><br><span class="line"><span class="comment">且这棵树本身符合堆的性质（此处为小根堆）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="comment">// 小根堆，根最小</span></span><br><span class="line">    <span class="keyword">if</span> (tree[x].val &gt; tree[y].val) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    tree[x].rc = <span class="built_in">merge</span>(tree[x].rc, y);</span><br><span class="line">    <span class="keyword">if</span> (tree[tree[x].lc].dist &lt; tree[tree[x].rc].dist) <span class="built_in">swap</span>(tree[x].lc, tree[x].rc);</span><br><span class="line">    tree[x].dist = tree[tree[x].rc].dist + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并查集路径压缩</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[x].fa == x ? x : tree[x].fa = <span class="built_in">find</span>(tree[x].fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tree[i].val);</span><br><span class="line">        tree[i].fa = i;</span><br><span class="line">        tree[i].lc = tree[i].rc = <span class="number">0</span>;</span><br><span class="line">        tree[i].dist = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span> (vis[x] || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 并查集找到两个点的根节点</span></span><br><span class="line">            tree[<span class="built_in">find</span>(x)].fa = tree[<span class="built_in">find</span>(y)].fa = <span class="built_in">merge</span>(<span class="built_in">find</span>(x), <span class="built_in">find</span>(y));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除操作</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> root = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree[root].val);</span><br><span class="line">            vis[root] = <span class="number">1</span>;</span><br><span class="line">            tree[root].fa = tree[tree[root].lc].fa = tree[tree[root].rc].fa = <span class="built_in">merge</span>(tree[root].lc, tree[root].rc);</span><br><span class="line">            tree[root].lc = tree[root].rc = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>可并堆(左偏树)</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P3805题解</title>
    <url>/posts/30b2f822/</url>
    <content><![CDATA[<p> 对于求回文串的要求，可以确定是从中间向两边扩散的算法，回文串可以分为偶回文串和奇回文串，为了方便，可以用不存在字符扩展整个回文串，使得偶回文串变成奇回文串，使得一个回文串一定存在一个回文中心。</p>
<p> Manacher的核心在于减少在计算回文串时每个字符被枚举的次数，假设分别以前<span
class="math inline">\(i-1\)</span>个字符作为回文中心，其最长回文长度已经求出，且回文串枚举最长枚举到最右侧<span
class="math inline">\(j\)</span>的位置，对应的回文中心为<span
class="math inline">\(center\)</span>，不妨设<span
class="math inline">\(j&gt;i\)</span>，那么此时，以<span
class="math inline">\(i\)</span>为中心的回文串长度<span
class="math inline">\(l_i\)</span>有一个下限</p>
<p><span class="math display">\[
    l_i = \min(l_{2*center-i},j-i)
\]</span></p>
<p>那么开始枚举就是从<span
class="math inline">\(i+l_i\)</span>之后的点开始判断是否构成以<span
class="math inline">\(i\)</span>为中心的回文串</p>
<p> 下面说明整体的复杂度为<span
class="math inline">\(\Theta(n)\)</span>，</p>
<p> 对于<span
class="math inline">\(i+l_i&lt;j\)</span>的情况，由于回文串的对称性，左右完全对称，那么以<span
class="math inline">\(i\)</span>为中心的回文串不可能再增加，因为如果增加的话，那么其对称点<span
class="math inline">\(2*center-i\)</span>的回文长度会增加，与事实不符。</p>
<p> 对于<span class="math inline">\(i+l_i=j\)</span>的情况，由于<span
class="math inline">\(j\)</span>右侧的情况未知，需要进行扩散判断是否能够构成回文串。</p>
<p> 可以看到每个点只会被枚举一次，故整体的复杂度为<span
class="math inline">\(\Theta(n)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">manacher</span> &#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 扩展字符串，使得不用区分奇偶回文串</span></span><br><span class="line">    <span class="function">string <span class="title">expandString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string result = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            result += s[i];</span><br><span class="line">            result += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    找到最长回文子串</span></span><br><span class="line"><span class="comment">    对于一个字符，如果它落在另一个回文串的内部，那么它的对称点也一定在这个回文串的内部，它的回文半径也一定等于它的对称点的回文半径且不会超过这个回文串的边界。</span></span><br><span class="line"><span class="comment">    通过这样的方法进行跳转，再判断之后的点是否符合回文串，可以在O(n)的时间复杂度内找到最长回文子串。因为每个点只枚举一次。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str = <span class="built_in">expandString</span>(s);</span><br><span class="line">        <span class="type">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">length</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxRight = <span class="number">0</span>, center = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ansCenter = <span class="number">0</span>, ansLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; maxRight) &#123;</span><br><span class="line">                length[i] = <span class="built_in">min</span>(length[<span class="number">2</span> * center - i], maxRight - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                length[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i - length[i] &gt;= <span class="number">0</span> &amp;&amp; i + length[i] &lt; n &amp;&amp; str[i - length[i]] == str[i + length[i]]) &#123;</span><br><span class="line">                length[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i + length[i] - <span class="number">1</span> &gt; maxRight) &#123;</span><br><span class="line">                maxRight = i + length[i] - <span class="number">1</span>;</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (length[i] &gt; ansLength) &#123;</span><br><span class="line">                ansLength = length[i];</span><br><span class="line">                ansCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于输出具体的字符串</span></span><br><span class="line">        <span class="comment">// string ans;</span></span><br><span class="line">        <span class="comment">// for(int i=ansCenter-(ansLength-1);i&lt;ansCenter+ansLength;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(str[i] == &#x27;#&#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//         continue;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     ans += str[i];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> ansLength - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>P3829题解</title>
    <url>/posts/b537952b/</url>
    <content><![CDATA[<p> 首先可以发现，如果半径为0，那么就是几个长方形之间求一个凸包，那么就是凸包的板，那么在半径不为0的情况下，首先根据样例，可以分析到对应的路径，如下图中绿色的线所示</p>
<figure>
<img src="image.png" alt="路径图" />
<figcaption aria-hidden="true">路径图</figcaption>
</figure>
<p>为了保证凸包，可以发现绿色的线与圆相切，此时考察一张信用卡中的4个圆心，观察所有的圆心组成的凸包，因为圆无法直接进行凸包运算，需要进行转化，猜测与圆心有关。那么如下图所示，可以得到圆心组成的凸包</p>
<figure>
<img src="image2.jpg" alt="圆心路径" />
<figcaption aria-hidden="true">圆心路径</figcaption>
</figure>
<p> 由分析可知，原凸包路径=圆心凸包路径+圆弧段长度，圆弧段的长度可以由下式算出</p>
<p><span class="math display">\[
    l_c = \theta*r = r*\sum_{i=1}^n \theta_i
\]</span></p>
<p>其中<span class="math inline">\(n\)</span>是圆弧对应的角<span
class="math inline">\(\theta_i\)</span>的个数，也是凸包内角<span
class="math inline">\(\alpha_i\)</span>个数，由几何关系可以知道，<span
class="math inline">\(\theta_i\)</span>和<span
class="math inline">\(\alpha_i\)</span>之间有如下的对应关系</p>
<p><span class="math display">\[
    \theta_i = \pi - \alpha_i
\]</span></p>
<p>那么带入圆弧长度的公式就有</p>
<p><span class="math display">\[
    l_c = r*\sum_{i=1}^n \theta_i = r*\sum_{i=1}^n (\pi-\alpha_i) = r *
(n\pi-\sum_{i=1}^n\alpha_i)\\
    = r*(n\pi-(n-2)\pi ) = 2\pi r
\]</span></p>
<p>故圆弧部分的长度固定，那么这道题就转换为求圆心组成的凸包的长度加上一个圆的周长</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">double</span> a, b, r, X[MAXN &lt;&lt; <span class="number">2</span>], Y[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> adx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">-0.5</span>&#125;, ady[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graham</span> &#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, pos, ans_stack[MAXN], ans_top;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">double</span> x, y;</span><br><span class="line">        node <span class="keyword">operator</span>-(node a) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;x - a.x, y - a.y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重载为叉乘运算</span></span><br><span class="line">        <span class="type">double</span> <span class="keyword">operator</span>*(node a) &#123;</span><br><span class="line">            <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重载为点积运算</span></span><br><span class="line">        <span class="type">double</span> <span class="keyword">operator</span>^(node a) &#123;</span><br><span class="line">            <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; node_list[MAXN], stap;</span><br><span class="line">    <span class="type">double</span> ans, eps = <span class="number">1e-7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(node i, node j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((i - j) ^ (i - j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    计算两个向量的叉乘</span></span><br><span class="line"><span class="comment">    如果结果小于0，说明向量a在向量b的逆时针方向，返回0</span></span><br><span class="line"><span class="comment">    如果结果大于0，说明向量a在向量b的顺时针方向，返回1</span></span><br><span class="line"><span class="comment">    对于等于0的情况，说明向量a和向量b共线,还需要判断两个向量的距离，若b距离原点更近，则返回1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> tmp = a * b;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; -eps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(tmp) &lt; eps) &#123;</span><br><span class="line">            <span class="type">double</span> dis1 = <span class="built_in">dist</span>(a, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;), dis2 = <span class="built_in">dist</span>(b, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (dis2 - dis1 &gt; eps) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断向量(新来的点-&gt;栈顶组成元素)是否在向量(新来的点-&gt;栈顶下一个元素)的顺时针方向</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">checkvalida</span><span class="params">(node a, node b, node c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(c - a, c - b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graham</span>() &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        ans_top = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Graham</span>(<span class="type">int</span> n, <span class="type">double</span> *x, <span class="type">double</span> *y) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        ans_top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            node_list[i].x = x[i];</span><br><span class="line">            node_list[i].y = y[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选择初始点，当枚举边采用逆时针旋转的方法时，选择最下方的点，当y值相同的时候，选择最左边的点</span></span><br><span class="line">        stap.y = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node_list[i].y &lt; stap.y || (node_list[i].y == stap.y &amp;&amp; node_list[i].x &lt; stap.x)) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                stap = node_list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">swap</span>(node_list[<span class="number">1</span>], node_list[pos]);</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(node_list + <span class="number">2</span>, node_list + n + <span class="number">1</span>,</span><br><span class="line">                  <span class="comment">// 按照与初始点的极角排序</span></span><br><span class="line">                  [&amp;](node a, node b) &#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="built_in">cmp</span>(a - stap, b - stap);</span><br><span class="line">                  &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断向量(新来的点-&gt;栈顶组成元素)是否在向量(新来的点-&gt;栈顶下一个元素)的顺时针方向即叉乘大于0，如果在，那么栈顶元素出栈，一定不会是最优解。</span></span><br><span class="line">            <span class="keyword">while</span> (ans_top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">checkvalida</span>(node_list[ans_stack[ans_top]], node_list[ans_stack[ans_top - <span class="number">1</span>]], node_list[i])) ans_top--;</span><br><span class="line">            ans_stack[++ans_top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= ans_top; i++) &#123;</span><br><span class="line">            ans += <span class="built_in">dist</span>(node_list[ans_stack[i]], node_list[ans_stack[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="built_in">dist</span>(node_list[ans_stack[<span class="number">1</span>]], node_list[ans_stack[ans_top]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> theta, <span class="type">int</span> pos, <span class="type">double</span> cx, <span class="type">double</span> cy)</span> </span>&#123;</span><br><span class="line">    X[pos] = cx + x * <span class="built_in">cos</span>(theta) - y * <span class="built_in">sin</span>(theta);</span><br><span class="line">    Y[pos] = cy + x * <span class="built_in">sin</span>(theta) + y * <span class="built_in">cos</span>(theta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;a, &amp;b, &amp;r);</span><br><span class="line">    std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">double</span> cx, cy, theta;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;cx, &amp;cy, &amp;theta);</span><br><span class="line">        <span class="comment">// 计算旋转后的圆心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; k++)</span><br><span class="line">            <span class="built_in">rotate</span>((a - <span class="number">2</span> * r) * adx[k], (b - <span class="number">2</span> * r) * ady[k], theta, (i - <span class="number">1</span>) * <span class="number">4</span> + k, cx, cy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Graham <span class="title">graham</span><span class="params">(N * <span class="number">4</span>, X, Y)</span></span>;</span><br><span class="line">    <span class="type">double</span> ans = graham.<span class="built_in">solve</span>() + <span class="number">2</span> * <span class="number">3.14159265358979323846</span> * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3917题解</title>
    <url>/posts/7cfcfdd6/</url>
    <content><![CDATA[<p>​ 这道题使用的是异或进行操作，异或运算也可以进行前缀和操作，而异或和的位之间具有独立性，两个二进制位之间的异或运算相互互不影响。</p>
<p>​ 这道题求<span
class="math inline">\(N\)</span>长序列的所有异或子序列之和，哪怕使用前缀异或和，其复杂度也是<span
class="math inline">\(\Theta(N^2)\)</span>，难以接受，故不能直接暴力计算其异或子序列之和，考虑计算不同序列的个数直接计算。可以将每个序列考虑拆成2的幂次相加的形式，即2进制表达。考虑异或操作的独立性，分别对于每一个二进制位统计其前缀和，单独的01序列方便直接判断其是否产生贡献，那么对于所有01序列，那么其产生的贡献次数为<span
class="math inline">\(num_1*num_0\)</span>，最终统计答案的时候，使用贡献次数乘上此时的系数即2的幂次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll N, A[MAXN], S[MAXN][<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;A[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++)</span><br><span class="line">            S[i][k] = S[i - <span class="number">1</span>][k] ^ ((A[i] &gt;&gt; k) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++) &#123;</span><br><span class="line">        ll num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i][k])</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += num * (N - num + <span class="number">1</span>) * (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>P4317题解</title>
    <url>/posts/b0e6c31/</url>
    <content><![CDATA[<p> 要求计算<span
class="math inline">\(\prod_{i=1}^{N}sum(i)\)</span>的值，N足够大，<span
class="math inline">\(sum(i)\)</span>是二进制表达中1的个数。可以打标出<span
class="math inline">\(sum(i)\)</span>的个数，那么从1到8的<span
class="math inline">\(sum\)</span>值对应如下</p>
<table>
<thead>
<tr class="header">
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(sum(i)\)</span></td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>可以发现<span
class="math inline">\(sum(i)\)</span>的值足够小，不超过其二进制位数的大小，故同样大小的<span
class="math inline">\(sum(i)\)</span>会重复出现，因为目标式子是求积，故可以把目标式子改写为
<span class="math display">\[
\prod_{i=1}^{N}sum(i) = \prod_{j=1}^{tot}j^{G_j}
\]</span> 其中<span class="math inline">\(j\)</span>为<span
class="math inline">\(sum(i)\)</span>可能出现的值，<span
class="math inline">\(G_j\)</span>对应着<span
class="math inline">\(sum(i)=j\)</span>出现的次数。那么原题转化为求解<span
class="math inline">\(G_j\)</span>，即对应不同值的<span
class="math inline">\(sum(i)\)</span>出现次数。可以想到这是一个数位DP。</p>
<p> 选取第一维度<span
class="math inline">\(i\)</span>为当前进行到了二进制表达下的第<span
class="math inline">\(i\)</span>位，因为是对二进制位进行操作，所以不需要考虑此时在最高位的数字是什么，可以省下一维。故第二维<span
class="math inline">\(j\)</span>表示当前统计的是<span
class="math inline">\(sum(x)=j\)</span>的个数。整体状态<span
class="math inline">\(f[i][j]\)</span>表示，当二进制最高位为<span
class="math inline">\(i\)</span>时，满足<span
class="math inline">\(sum(x)=j\)</span>的<span
class="math inline">\(x\)</span>的数量。</p>
<p> 那么可以知道计算<span class="math inline">\(f\)</span>的转移方程为
<span class="math display">\[
f[i][j] = \sum_{k=j-1}^{i-1}f[k][j-1]
\]</span>  因为<span
class="math inline">\(f[i][j]\)</span>表示当前的二进制位中有<span
class="math inline">\(j\)</span>个1且 最高位的1在第<span
class="math inline">\(i\)</span>位上，那么其个数应该由二进制表达中有<span
class="math inline">\(j-1\)</span>个1的状态转移而来，因为此时确定了最高位为<span
class="math inline">\(i\)</span>那么枚举第一维的上限应该就是<span
class="math inline">\(i-1\)</span>，所以应该枚举最高位可能出现的位置，并将对应的值相加作为<span
class="math inline">\(f[i][j]\)</span>的值。</p>
<p> 对于答案的统计，首先明确，分开统计不同<span
class="math inline">\(sum(x)\)</span>取值，依次枚举，不妨假设需要统计<span
class="math inline">\(sum(x)=j\)</span>， 开始依次枚举<span
class="math inline">\(j\)</span>。接下来，对于给出的上限<span
class="math inline">\(N\)</span>，从它的二进制最高位到最低位开始枚举（从高位到低位枚举，保证统计的内容来源一定时小于<span
class="math inline">\(N\)</span>的数，这一点与比大小的过程相同）</p>
<p> 取<span class="math inline">\(N\)</span>的二进制表达为<span
class="math inline">\(a_1,a_2,a_3,\dots,a_n\)</span>，</p>
<ul>
<li>如果此时<span
class="math inline">\(a_i=1\)</span>，那么计算当第<span
class="math inline">\(i\)</span>位为0时，剩余位数产生的贡献即<span
class="math inline">\(f[i-1][tmp]\)</span>，其中<span
class="math inline">\(tmp\)</span>表示为统计目标值<span
class="math inline">\(j\)</span>减去从<span
class="math inline">\(n\)</span>的二进制表达中第<span
class="math inline">\(i\)</span>位到<span
class="math inline">\(n\)</span>位中的已确定的1的数量，表示为<span
class="math inline">\(tmp = j -
num_1\)</span>，如果发现现在计算完成后，计算上当前位置上的1后即<span
class="math inline">\(num_1+1\)</span>，大于目标<span
class="math inline">\(j\)</span>，那么不再进行枚举，因为<span
class="math inline">\(num_1+1&gt;j\)</span>说明在确定完这一位之后，无论后续怎么枚举，含有的1个数总会多于目标<span
class="math inline">\(j\)</span>，故跳出循环，开始枚举下一个<span
class="math inline">\(j\)</span>.</li>
<li>如果此时<span class="math inline">\(a_i=0\)</span>，那么跳过。</li>
</ul>
<p>计算完成后继续枚举<span
class="math inline">\(a_{i-1}\)</span>位。在完成枚举到最低的二进制位之后，那么如果目标位数<span
class="math inline">\(j\)</span>与<span
class="math inline">\(N\)</span>本身含有的1的个数相同，即<span
class="math inline">\(tmp=j-num_1=0\)</span>时，<span
class="math inline">\(N\)</span>本身会对目标<span
class="math inline">\(j\)</span>产生贡献，需要最后补上本身带来的贡献。</p>
<p> 最终对于输出的答案，按需要计算幂次即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 10000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 55</span></span><br><span class="line">ll dp[MAXN][MAXN];</span><br><span class="line">ll G[MAXN];</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j - <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                dp[i][j] += dp[k][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % MOD;</span><br><span class="line">        a = a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        a[++tot] = n % <span class="number">2</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tot; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = tmp; k &lt; i; k++)</span><br><span class="line">                    G[j] += dp[k][tmp];</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                tmp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; tmp == <span class="number">0</span>) G[j] += dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        ans = ans * <span class="built_in">quickpow</span>(i, G[i]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
</search>
