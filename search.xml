<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>P1972题解</title>
    <url>/posts/ec5e0bcb/</url>
    <content><![CDATA[<p> 这道题需要明确的是，查询的是种类个数，故多个相同种类的点带来的贡献只有一个有效。假设只有最右端有效，那么从左到右依次更改，出现一个新的种类时，删去原来位置上的贡献，更新当前位置上的贡献。更改到第
i个的时候，那么对于这个区间，可以采用前缀和的方式求得所有的右区间为i的查询的结果，因为假设一个类别出现在L左侧和右侧，那么根据更新规则，一定是在L右侧的点产生贡献，保证不漏，不出现在L右侧的点，不会在<span
class="math inline">\([L,R]\)</span>之间产生贡献。采用区间查询的方式，一次性告诉所有查询，可以采用离线查询后返回的方式得到答案。故采用每个区间最右侧作为排序基准。每次修改的只是一个点，只用枚举完整个序列，为<span
class="math inline">\(\Theta(n)\)</span>.
 整个过程区间查询，单点修改，为了保证其效率的优秀，采用的是树状数组对整个数组进行操作</p>
]]></content>
  </entry>
  <entry>
    <title>P1542题解</title>
    <url>/posts/84e5ff3c/</url>
    <content><![CDATA[<p> 这道题在于找到一个最小的速度，通过这个速度能够满足要求的跑完全程。可以直接二分速度来设置上限，对于速度可以小的路径段，早到了位置可以进行等待。故正确性可以保证。</p>
]]></content>
  </entry>
  <entry>
    <title>P2157题解</title>
    <url>/posts/acac3a0a/</url>
    <content><![CDATA[<p>​ 当前是否选择第<span
class="math inline">\(i\)</span>个人取吃饭受到他之前的人和他之后的人影响，不符合无后效性的定义，而他之后的人根据题目要求最多只有8个，可以考虑使用状态压缩，把第<span
class="math inline">\(i\)</span>个人和其后面7个人是否吃饭作为状态进行压缩，故DP的一个维度为状态，大小为256。</p>
<p>​ 不妨取第一维<span class="math inline">\(i\)</span>表示前<span
class="math inline">\(i\)</span>-1个人都吃完成，第二维<span
class="math inline">\(j\)</span>表示第<span
class="math inline">\(i\)</span>个人和他后面7个人是否吃饭的状态，采用小端表示，即表示第<span
class="math inline">\(i\)</span>个人的二进制位为最低位（主要是方便）。</p>
<p>​ 因为更新权值需要知道上一个吃饭的是谁，故需要第三维表示上一个吃饭的是谁，为了保证全局最优解，故需要记录状态，而非仅记录当前产生贡献（最大值）中选取的上一个吃饭的是谁，虽然第1维表示前面<span
class="math inline">\(i\)</span>-1个人吃了饭，但是前面的人吃饭顺序不确定，所以这一维度需要表示的范围从第<span
class="math inline">\(i\)</span>个人的前到第<span
class="math inline">\(i\)</span>个人的后。而最大的容忍插队是8个，故如果当前要选择第<span
class="math inline">\(i\)</span>个人吃饭，那么必然上一个吃饭的人的范围在第<span
class="math inline">\(i\)</span>个人前8个之间，否则不符合仅允许后<span
class="math inline">\(B_i\)</span>个人吃饭的要求。故第三维的范围为<span
class="math inline">\([-8,7]\)</span>，为了使得数组下标不为负，那么可以修改范围为<span
class="math inline">\([0,15]\)</span></p>
<p>​ 故可以把DP方程写为 <span class="math display">\[
f[i][j][k]
\]</span>
​ 那么对于DP方程的转移，首先如何转移第一维的值。根据第一维的规则，<span
class="math inline">\(i\)</span>表示前<span
class="math inline">\(i\)</span>-1个人吃完饭，可知如果第<span
class="math inline">\(i\)</span>个人吃完饭了，就可以进行转移，即<span
class="math inline">\(j\)</span>的最低位为1时，就可以转移了，所以转移的规则为
<span class="math display">\[
f[i+1][j&gt;&gt;1][k-1] = min(f[i+1][j&gt;&gt;1][k-1],f[i][j][k])\quad
(j\&amp;1==1)
\]</span> ​ 在这种情况下，<span
class="math inline">\(f[i+1][j&gt;&gt;1][k-1]\)</span>与<span
class="math inline">\(f[i][j][k]\)</span>等价，故优先转移第一维，使用<span
class="math inline">\(f[i+1][j&gt;&gt;1][k-1]\)</span>对于后续的情况进行更新，减少了第一维转移的个数。</p>
<p>​ 对于<span
class="math inline">\(j\)</span>最后一位不为1的情况，可以枚举当前吃饭的是谁，即选择<span
class="math inline">\(j\)</span>中二进制位为0的位置，让这个位置的人吃饭，那么更新规则为
<span class="math display">\[
f[i][j|(1&lt;&lt;z)][k] =
min(f[i][j|(1&lt;&lt;z)][k],f[i][j][k]+T[i+z]\oplus T[i+k])\quad
(j\&amp;1!=1)
\]</span> ​ 那么<span
class="math inline">\(i+z\)</span>上的人能否吃饭受到第<span
class="math inline">\(i\)</span>个人容许的限度和<span
class="math inline">\([i+1,i+z-1]\)</span>之间没有吃饭的人的容许限度的限制。即<span
class="math inline">\(z\)</span>的选择大小需要考虑他到<span
class="math inline">\(i\)</span>之间没有吃饭的人的容许情况。（这一点不考虑完整只考虑i的容许的话只有32%的正确）。</p>
<p>​ 在更新时，还需要考虑是否是第一个人，第一个人不计算时间。</p>
<p>​ 根据上式转移方程，那么初始值可以选择为 <span class="math display">\[
f[1][0][7]=0
\]</span>
表示当前进行到第一个人，当前状态是0，上一个吃饭的人设置为第0个人，表示不存在。</p>
]]></content>
  </entry>
  <entry>
    <title>P1247题解</title>
    <url>/posts/b2bcbd52/</url>
    <content><![CDATA[<p> 对于取火柴的题目，就是取石子即Nim均衡，如果每个堆的大小异或起来为0，那么此时必输，那么找必胜策略的方法为对于其中一个堆，取出石子使得剩下的石子的个数等于其余堆的异或和。
<span id="more"></span> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> k, a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) tmp = tmp ^ a[i];</span><br><span class="line">    <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lose\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i] ^ tmp;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; a[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a[i] - x, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>博弈论</tag>
        <tag>NIM均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>P2254题解</title>
    <url>/posts/a4c91c52/</url>
    <content><![CDATA[<p> 题面中的魔法的含义是1900在该时间段的最大滑动距离是时间段的长度，并不关心具体在哪个位置时使用了魔法使得1900暂停（题目没问，且对于一条可行的路径，其使用魔法的可行选项并不唯一）。</p>
<p> 故可以不按照时间进行枚举，而是对于时间段进行枚举，（减少必须枚举的数量），将一个时间段内依次枚举改为找到一个时间段内可能对于当前点产生贡献的点并找到其中的最大值</p>
<p> 那么对于第<span class="math inline">\(i\)</span>个时间段<span
class="math inline">\([s_i,t_i]\)</span>，对于当前点<span
class="math inline">\((x,y)\)</span>处，其到达这个位置可能的最大路径长度由逆着滑动方向，滑动距离不超过时间段长度，且滑动过程中没有障碍物的情况下能够到达的点的集合中，之前的路径长度加上第<span
class="math inline">\(i\)</span>个时间段内需要移动的滑动距离最大的点提供。</p>
<p> 不妨设状态为<span
class="math inline">\(f[k][x][y]\)</span>，表示当前在第<span
class="math inline">\(k\)</span>个时间段到达点<span
class="math inline">\((x,y)\)</span>时能够获得的最大路径，那么可以根据上面的分析将状态转移方程写为
<span class="math display">\[
f[k][x][y] =
max(f[k][x][y],f[k-1][x+t*d[x]][y+t*d[y]]+t*(abs(d[x])+abs(d[y])))
\]</span> 转移条件为 <span class="math display">\[
s_i\leq t\leq t_i \quad 且 \quad (x+t*d[x],y+t*d[y])到(x,y)之间无障碍物
\]</span> 此时的时间复杂度可以知道为<span
class="math inline">\(\Theta(KNMN)\)</span>，其中<span
class="math inline">\(K\)</span>来自枚举时间段，<span
class="math inline">\(NM\)</span>来自枚举图中每一个点，<span
class="math inline">\(N\)</span>来自对于每一个点去找到他的最大值，当<span
class="math inline">\(K,N,M\)</span>取200时，时间复杂度来到<span
class="math inline">\(1.6\times10^9\)</span>，如果计算上常数，其复杂度难以接受。</p>
<p> 对于一个时间段内进行更新的话，可以发现其中对于每个点来说，其需要向前找的距离一致，那么就是一个滑动窗口，可以采用单调队列进行优化。此时找的是最大值，那么维护的是一个单调递减队列。单调队列保证其内容递减，当一个新的值入队，那么从后向前删除队中比他小的值，这些值在之后的更新中将不会有机会产生贡献，并将这个值插入队尾。接着从头开始枚举，删除不在窗口中的值。</p>
<p> 对于这道题来说，每次移动的方向是确定的，假设向下移动，那么对于每一个列来说其是相互独立的，不会相互影响，可以从上到下依次更新。对于每一列，采用一个单调队列，设当前为时间段<span
class="math inline">\(k\)</span>，那么将<span
class="math inline">\(k-1\)</span>时间段中在位置<span
class="math inline">\((x,y)\)</span>的<span
class="math inline">\(f\)</span>值取出，放入单调队列并维护这个单调队列合法，注意此时单调队列的大小判断方式为对应位置的上一时刻<span
class="math inline">\(f\)</span>值加上在这一时刻移动的距离，之后用单调队列的队首即最大贡献更新。如果遇到了障碍，说明障碍前的点不会更新障碍后的点，那么可以将队列清空，那么此时通过势能分析法，每个点都只会被枚举一次，那么消去了循环最内层带来枚举最大值的时间复杂度，整体时间复杂度变为<span
class="math inline">\(\Theta(KNM)\)</span>，空间复杂度同样为<span
class="math inline">\(\Theta(KNM)\)</span>，由于更新方程只与上一个时刻有关，可以将第一维优化为只有0，1两个值，或者直接消去第一维。</p>
]]></content>
  </entry>
  <entry>
    <title>P2607题解</title>
    <url>/posts/802d59a7/</url>
    <content><![CDATA[<p> 对于这道题，可以明确的是，这道题和没有上司的舞会是一致的（升级版）。这道题的改变在于，这个图中会出现简单的环，且这个环不会出现环中环的情况，故可以不去找桥，而是直接把这个环中选择一条边，强制删去，然后剩余的连通块可以看作一颗树，与没有上司的舞会是一样的。而对于整个连通块答案的统计可以选择被删去边两侧的点，依次枚举两者不被选择的情况。（保证不会冲突，如果枚举两个点被选取的情况，因为DP的无后效性，会出现A点被选取，但是B点因为一条边被删去，故同样的被选取的情况。）（只枚举不被选取的情况的正确性还可以有A，B中有边相连，可能出现的情况只有三种，（选A）（选B）（A，B都不要））</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> next,to;</span><br><span class="line">&#125;e[<span class="number">2</span>*MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN],cnt,val[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN],n;</span><br><span class="line"><span class="type">int</span> S,T,cut_edge[<span class="number">2</span>*MAXN],flag;</span><br><span class="line">LL f[MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d\n&quot;,u,v);</span></span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            S=u;T=v;</span><br><span class="line">            cut_edge[i]=cut_edge[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>]=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> to=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa||cut_edge[i]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getans</span>(to,u);</span><br><span class="line">        f[u][<span class="number">0</span>]+=(LL)<span class="built_in">max</span>(f[to][<span class="number">0</span>],f[to][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>]+=(LL)f[to][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;val[i],&amp;tmp);</span><br><span class="line">        <span class="built_in">addedge</span>(i,tmp);</span><br><span class="line">        <span class="built_in">addedge</span>(tmp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">getans</span>(S,<span class="number">0</span>);</span><br><span class="line">        LL temp = f[S][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">getans</span>(T,<span class="number">0</span>);</span><br><span class="line">        temp = <span class="built_in">max</span>(temp,f[T][<span class="number">0</span>]);</span><br><span class="line">        ans += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
        <tag>环</tag>
      </tags>
  </entry>
  <entry>
    <title>P2742题解</title>
    <url>/posts/41246cb9/</url>
    <content><![CDATA[<h2 id="暴力">暴力</h2>
<p> 对于求凸包的题，暴力的方法，从最左下的点开始，旋转一条边，找所有的点中最早与这条边重合的，这样做时间复杂度为<span
class="math inline">\(\Theta(nm)\)</span></p>
<h2 id="graham">Graham</h2>
<p> 考虑优化枚举顺序，使得每次不用重新判断每个点是否出现在这条线上，可以发现，一个凸包从左下角开始，逆时针依次枚举，路径上的点与左下角组成的直线角度逐渐增大，可以在选取了左下点后，以左下角与其他点组成的向量的角度大小作为排序基准，进行排序，以排序后的顺序作为枚举顺序。</p>
<p> 使用一个栈存下路径上的点，对于新进入的点<span
class="math inline">\(C\)</span>，假设此时栈顶的元素为<span
class="math inline">\(A\)</span>，栈顶下一个点为<span
class="math inline">\(B\)</span>，点<span
class="math inline">\(C\)</span>此时一定进入栈中，但是点<span
class="math inline">\(A\)</span>是否出栈，即点<span
class="math inline">\(A\)</span>是否在<span
class="math inline">\(CB\)</span>的连线之内，若在，那么<span
class="math inline">\(A\)</span>显然不再路径上，<span
class="math inline">\(A\)</span>出栈。下图是一个<span
class="math inline">\(A\)</span>在<span
class="math inline">\(CB\)</span>内的示意图。</p>
<figure>
<img src="image.png" alt="A在图中" />
<figcaption aria-hidden="true">A在图中</figcaption>
</figure>
<p>对于上面的情况，判断是否在凸包内可以采用向量叉乘，通过向量叉乘的<span
class="math inline">\(z\)</span>维的正负判断。叉乘计算方式为</p>
<p><span class="math display">\[
\begin{align*}
    \vec{a} \times \vec{b} &amp;= \left| \begin{matrix}
    \vec{i} &amp; \vec{j} &amp; \vec{k} \\
    \hline
    a_i &amp; a_j &amp; a_k\\
    b_i &amp; b_j &amp; b_k
\end{matrix}\right| \\
    &amp;= (a_j\cdot b_k-a_k\cdot b_j,-(a_i\cdot b_k-a_k\cdot
b_i),a_i\cdot b_j-a_j\cdot b_i)
\end{align*}
\]</span></p>
<p> 当<span class="math inline">\(z\)</span>轴均取0时，只保留值<span
class="math inline">\(a_i\cdot b_j-a_j\cdot b_i\)</span>，当<span
class="math inline">\(\vec{a}\)</span>沿逆时针方向转向<span
class="math inline">\(\vec{b}\)</span>时，<span
class="math inline">\(a_i\cdot b_j-a_j\cdot b_i &gt;
0\)</span>，可以由极坐标证明这个关系。</p>
<p> 那么判断条件变成计算<span
class="math inline">\(\vec{CA}\times\vec{CB}\)</span>，若值大于0，则证明点<span
class="math inline">\(A\)</span>需要出栈，若值等于0，则证明<span
class="math inline">\(\vec{CA}\)</span>和<span
class="math inline">\(\vec{CB}\)</span>共线，选择长度最长的那条边，才保证符合凸包的条件。</p>
<p> 需要注意这个过程需要一直进行，直到找到一个<span
class="math inline">\(\vec{CA}\)</span>和<span
class="math inline">\(\vec{CB}&lt;0\)</span>的点，再把点<span
class="math inline">\(C\)</span>插入栈中。</p>
<p> 最后得到答案需要加上栈中最后一个点到起始点的距离。</p>
<p> 排序效率为<span class="math inline">\(\Theta(n\log
n)\)</span>，扫描过程效率为<span
class="math inline">\(\Theta(n)\)</span></p>
<h2 id="andrew">Andrew</h2>
<p> Andrew算法使用不同的排序方法，按照<span
class="math inline">\(x\)</span>轴坐标的大小排序，判断过程一致，需要注意，Andrew算法从左到右只能枚举凸包的一半，还需要从结束点枚举回开始点。注意第二次枚举的时候通过栈记录路径时，出栈不能把前一半凸包（在上述枚举条件下，为下凸包）的路径清理掉。</p>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3377题解</title>
    <url>/posts/2fbd7ecf/</url>
    <content><![CDATA[<p> 这是一个基本的左偏树(可并堆)的模板，左偏树就是定义了距离<span
class="math inline">\(dist\)</span>，要求左子树的<span
class="math inline">\(dist\)</span>大于右子树的<span
class="math inline">\(dist\)</span>， <span
class="math inline">\(dist\)</span>定义为根到外点的距离，外点定义为一个子树的点，计算方式为边权之和，（可为层高差）</p>
<p> 并查集中对于根节点的删除，在给根节点删除之后，把根节点的父亲数组指向他的子节点。</p>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>可并堆(左偏树)</tag>
      </tags>
  </entry>
</search>
