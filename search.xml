<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>P1247题解</title>
    <url>/posts/b2bcbd52/</url>
    <content><![CDATA[<p> 对于取火柴的题目，就是取石子即Nim均衡，如果每个堆的大小异或起来为0，那么此时必输，那么找必胜策略的方法为对于其中一个堆，取出石子使得剩下的石子的个数等于其余堆的异或和。
<span id="more"></span> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> k, a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) tmp = tmp ^ a[i];</span><br><span class="line">    <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lose\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i] ^ tmp;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; a[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a[i] - x, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>博弈论</tag>
        <tag>NIM均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>P1542题解</title>
    <url>/posts/84e5ff3c/</url>
    <content><![CDATA[<p> 这道题在于找到一个最小的速度，通过这个速度能够满足要求的跑完全程。可以直接二分速度来设置上限，对于速度可以小的路径段，早到了位置可以进行等待。故正确性可以保证。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> ti;</span><br><span class="line"><span class="type">int</span> x[MAXN], y[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">double</span> v)</span> </span>&#123;</span><br><span class="line">    ti = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ti += (<span class="type">long</span> <span class="type">double</span>)s[i] / v;</span><br><span class="line">        <span class="keyword">if</span> (ti &gt; y[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ti &lt; x[i]) ti = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x[i], &amp;y[i], &amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> l = <span class="number">0.0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid - <span class="number">1e-7</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1e-7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2Lf\n&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>P1972题解</title>
    <url>/posts/ec5e0bcb/</url>
    <content><![CDATA[<p> 这道题需要明确的是，查询的是种类个数，故多个相同种类的点带来的贡献只有一个有效。假设只有最右端有效，那么从左到右依次更改，出现一个新的种类时，删去原来位置上的贡献，更新当前位置上的贡献。更改到第
i个的时候，那么对于这个区间，可以采用前缀和的方式求得所有的右区间为i的查询的结果，因为假设一个类别出现在L左侧和右侧，那么根据更新规则，一定是在L右侧的点产生贡献，保证不漏，不出现在L右侧的点，不会在<span
class="math inline">\([L,R]\)</span>之间产生贡献。采用区间查询的方式，一次性告诉所有查询，可以采用离线查询后返回的方式得到答案。故采用每个区间最右侧作为排序基准。每次修改的只是一个点，只用枚举完整个序列，为<span
class="math inline">\(\Theta(n)\)</span></p>
<p> 整个过程区间查询，单点修改，为了保证其效率的优秀，采用的是树状数组对整个数组进行操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rg register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">queryy</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> queryy &amp;q) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; q.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, a[MAXN], tree[MAXN], last[MAXN], ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fread</span><span class="params">(<span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch) &amp;&amp; ch ^ <span class="string">&#x27;-&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rg i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        tree[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (rg i = x; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        res += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fread</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (rg i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">fread</span>(a[i]);</span><br><span class="line">    <span class="built_in">fread</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (rg i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">fread</span>(q[i].l);</span><br><span class="line">        <span class="built_in">fread</span>(q[i].r);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> lastr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (rg i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (rg j = lastr; j &lt;= q[i].r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last[a[j]]) <span class="built_in">modify</span>(last[a[j]], <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">modify</span>(j, <span class="number">1</span>);</span><br><span class="line">            last[a[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        lastr = q[i].r;</span><br><span class="line">        ans[q[i].id] = <span class="built_in">query</span>(q[i].r) - <span class="built_in">query</span>(q[i].l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rg i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
        <tag>前缀和</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>P2157题解</title>
    <url>/posts/acac3a0a/</url>
    <content><![CDATA[<p>​ 当前是否选择第<span
class="math inline">\(i\)</span>个人取吃饭受到他之前的人和他之后的人影响，不符合无后效性的定义，而他之后的人根据题目要求最多只有8个，可以考虑使用状态压缩，把第<span
class="math inline">\(i\)</span>个人和其后面7个人是否吃饭作为状态进行压缩，故DP的一个维度为状态，大小为256。</p>
<p>​ 不妨取第一维<span class="math inline">\(i\)</span>表示前<span
class="math inline">\(i\)</span>-1个人都吃完成，第二维<span
class="math inline">\(j\)</span>表示第<span
class="math inline">\(i\)</span>个人和他后面7个人是否吃饭的状态，采用小端表示，即表示第<span
class="math inline">\(i\)</span>个人的二进制位为最低位（主要是方便）。</p>
<p>​ 因为更新权值需要知道上一个吃饭的是谁，故需要第三维表示上一个吃饭的是谁，为了保证全局最优解，故需要记录状态，而非仅记录当前产生贡献（最大值）中选取的上一个吃饭的是谁，虽然第1维表示前面<span
class="math inline">\(i\)</span>-1个人吃了饭，但是前面的人吃饭顺序不确定，所以这一维度需要表示的范围从第<span
class="math inline">\(i\)</span>个人的前到第<span
class="math inline">\(i\)</span>个人的后。而最大的容忍插队是8个，故如果当前要选择第<span
class="math inline">\(i\)</span>个人吃饭，那么必然上一个吃饭的人的范围在第<span
class="math inline">\(i\)</span>个人前8个之间，否则不符合仅允许后<span
class="math inline">\(B_i\)</span>个人吃饭的要求。故第三维的范围为<span
class="math inline">\([-8,7]\)</span>，为了使得数组下标不为负，那么可以修改范围为<span
class="math inline">\([0,15]\)</span></p>
<p>​ 故可以把DP方程写为 <span class="math display">\[
f[i][j][k]
\]</span>
​ 那么对于DP方程的转移，首先如何转移第一维的值。根据第一维的规则，<span
class="math inline">\(i\)</span>表示前<span
class="math inline">\(i\)</span>-1个人吃完饭，可知如果第<span
class="math inline">\(i\)</span>个人吃完饭了，就可以进行转移，即<span
class="math inline">\(j\)</span>的最低位为1时，就可以转移了，所以转移的规则为
<span class="math display">\[
f[i+1][j&gt;&gt;1][k-1] = min(f[i+1][j&gt;&gt;1][k-1],f[i][j][k])\quad
(j\&amp;1==1)
\]</span> ​ 在这种情况下，<span
class="math inline">\(f[i+1][j&gt;&gt;1][k-1]\)</span>与<span
class="math inline">\(f[i][j][k]\)</span>等价，故优先转移第一维，使用<span
class="math inline">\(f[i+1][j&gt;&gt;1][k-1]\)</span>对于后续的情况进行更新，减少了第一维转移的个数。</p>
<p>​ 对于<span
class="math inline">\(j\)</span>最后一位不为1的情况，可以枚举当前吃饭的是谁，即选择<span
class="math inline">\(j\)</span>中二进制位为0的位置，让这个位置的人吃饭，那么更新规则为
<span class="math display">\[
f[i][j|(1&lt;&lt;z)][k] =
min(f[i][j|(1&lt;&lt;z)][k],f[i][j][k]+T[i+z]\oplus T[i+k])\quad
(j\&amp;1!=1)
\]</span> ​ 那么<span
class="math inline">\(i+z\)</span>上的人能否吃饭受到第<span
class="math inline">\(i\)</span>个人容许的限度和<span
class="math inline">\([i+1,i+z-1]\)</span>之间没有吃饭的人的容许限度的限制。即<span
class="math inline">\(z\)</span>的选择大小需要考虑他到<span
class="math inline">\(i\)</span>之间没有吃饭的人的容许情况。（这一点不考虑完整只考虑i的容许的话只有32%的正确）。</p>
<p>​ 在更新时，还需要考虑是否是第一个人，第一个人不计算时间。</p>
<p>​ 根据上式转移方程，那么初始值可以选择为 <span class="math display">\[
f[1][0][7]=0
\]</span>
表示当前进行到第一个人，当前状态是0，上一个吃饭的人设置为第0个人，表示不存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> C;</span><br><span class="line"><span class="type">int</span> T[MAXN], B[MAXN], f[MAXN][<span class="number">300</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettime</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T[i] ^ T[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;C);</span><br><span class="line">    <span class="keyword">while</span> (C--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;T[i], &amp;B[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++)</span><br><span class="line">                    f[i][j][k] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-8</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f[i][j][k + <span class="number">8</span>] != <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                            f[i + <span class="number">1</span>][j &gt;&gt; <span class="number">1</span>][k + <span class="number">7</span>] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][j &gt;&gt; <span class="number">1</span>][k + <span class="number">7</span>], f[i][j][k + <span class="number">8</span>]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">int</span> limitb = <span class="built_in">min</span>(i + B[i], n);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; i + z &lt;= limitb; z++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!((j &gt;&gt; z) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                                    f[i][j | (<span class="number">1</span> &lt;&lt; z)][z + <span class="number">8</span>] = <span class="built_in">min</span>(f[i][j | (<span class="number">1</span> &lt;&lt; z)][z + <span class="number">8</span>], f[i][j][k + <span class="number">8</span>] + ((i + k) ? <span class="built_in">gettime</span>(i + k, i + z) : <span class="number">0</span>));</span><br><span class="line">                                    limitb = <span class="built_in">min</span>(limitb, i + z + B[i + z]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-8</span>; k &lt; <span class="number">0</span>; k++) ans = <span class="built_in">min</span>(ans, f[n + <span class="number">1</span>][<span class="number">0</span>][k + <span class="number">8</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>P2254题解</title>
    <url>/posts/a4c91c52/</url>
    <content><![CDATA[<p> 题面中的魔法的含义是1900在该时间段的最大滑动距离是时间段的长度，并不关心具体在哪个位置时使用了魔法使得1900暂停（题目没问，且对于一条可行的路径，其使用魔法的可行选项并不唯一）。</p>
<p> 故可以不按照时间进行枚举，而是对于时间段进行枚举，（减少必须枚举的数量），将一个时间段内依次枚举改为找到一个时间段内可能对于当前点产生贡献的点并找到其中的最大值</p>
<p> 那么对于第<span class="math inline">\(i\)</span>个时间段<span
class="math inline">\([s_i,t_i]\)</span>，对于当前点<span
class="math inline">\((x,y)\)</span>处，其到达这个位置可能的最大路径长度由逆着滑动方向，滑动距离不超过时间段长度，且滑动过程中没有障碍物的情况下能够到达的点的集合中，之前的路径长度加上第<span
class="math inline">\(i\)</span>个时间段内需要移动的滑动距离最大的点提供。</p>
<p> 不妨设状态为<span
class="math inline">\(f[k][x][y]\)</span>，表示当前在第<span
class="math inline">\(k\)</span>个时间段到达点<span
class="math inline">\((x,y)\)</span>时能够获得的最大路径，那么可以根据上面的分析将状态转移方程写为
<span class="math display">\[
f[k][x][y] =
max(f[k][x][y],f[k-1][x+t*d[x]][y+t*d[y]]+t*(abs(d[x])+abs(d[y])))
\]</span> 转移条件为 <span class="math display">\[
s_i\leq t\leq t_i \quad 且 \quad (x+t*d[x],y+t*d[y])到(x,y)之间无障碍物
\]</span> 此时的时间复杂度可以知道为<span
class="math inline">\(\Theta(KNMN)\)</span>，其中<span
class="math inline">\(K\)</span>来自枚举时间段，<span
class="math inline">\(NM\)</span>来自枚举图中每一个点，<span
class="math inline">\(N\)</span>来自对于每一个点去找到他的最大值，当<span
class="math inline">\(K,N,M\)</span>取200时，时间复杂度来到<span
class="math inline">\(1.6\times10^9\)</span>，如果计算上常数，其复杂度难以接受。</p>
<p> 对于一个时间段内进行更新的话，可以发现其中对于每个点来说，其需要向前找的距离一致，那么就是一个滑动窗口，可以采用单调队列进行优化。此时找的是最大值，那么维护的是一个单调递减队列。单调队列保证其内容递减，当一个新的值入队，那么从后向前删除队中比他小的值，这些值在之后的更新中将不会有机会产生贡献，并将这个值插入队尾。接着从头开始枚举，删除不在窗口中的值。</p>
<p> 对于这道题来说，每次移动的方向是确定的，假设向下移动，那么对于每一个列来说其是相互独立的，不会相互影响，可以从上到下依次更新。对于每一列，采用一个单调队列，设当前为时间段<span
class="math inline">\(k\)</span>，那么将<span
class="math inline">\(k-1\)</span>时间段中在位置<span
class="math inline">\((x,y)\)</span>的<span
class="math inline">\(f\)</span>值取出，放入单调队列并维护这个单调队列合法，注意此时单调队列的大小判断方式为对应位置的上一时刻<span
class="math inline">\(f\)</span>值加上在这一时刻移动的距离，之后用单调队列的队首即最大贡献更新。如果遇到了障碍，说明障碍前的点不会更新障碍后的点，那么可以将队列清空，那么此时通过势能分析法，每个点都只会被枚举一次，那么消去了循环最内层带来枚举最大值的时间复杂度，整体时间复杂度变为<span
class="math inline">\(\Theta(KNM)\)</span>，空间复杂度同样为<span
class="math inline">\(\Theta(KNM)\)</span>，由于更新方程只与上一个时刻有关，可以将第一维优化为只有0，1两个值，或者直接消去第一维。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 205</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N, M, K, X, Y, s, t, d;</span><br><span class="line"><span class="type">char</span> ch[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, flag;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x1 - x2) + <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    deque&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= N &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= M; i++, x += dx[d], y += dy[d]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[x][y] == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">            q.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[x][y][flag] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">back</span>().val + <span class="built_in">dist</span>(q.<span class="built_in">back</span>().x, q.<span class="built_in">back</span>().y, x, y) &lt;= dp[x][y][flag]) &#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>((node)&#123;x, y, dp[x][y][flag]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">dist</span>(q.<span class="built_in">front</span>().x, q.<span class="built_in">front</span>().y, x, y) &gt; len) &#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            dp[x][y][flag ^ <span class="number">1</span>] = <span class="built_in">max</span>(dp[x][y][flag ^ <span class="number">1</span>], q.<span class="built_in">front</span>().val + <span class="built_in">dist</span>(q.<span class="built_in">front</span>().x, q.<span class="built_in">front</span>().y, x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;N, &amp;M, &amp;X, &amp;Y, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[X][Y][flag] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;d);</span><br><span class="line">        <span class="type">int</span> len = t - s + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">                    <span class="built_in">modify</span>(d, N, i, len);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">                    <span class="built_in">modify</span>(d, <span class="number">1</span>, i, len);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">                    <span class="built_in">modify</span>(d, i, M, len);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">                    <span class="built_in">modify</span>(d, i, <span class="number">1</span>, len);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i][j][flag]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>P2607题解</title>
    <url>/posts/802d59a7/</url>
    <content><![CDATA[<p> 对于这道题，可以明确的是，这道题和没有上司的舞会是一致的（升级版）。这道题的改变在于，这个图中会出现简单的环，且这个环不会出现环中环的情况，故可以不去找桥，而是直接把这个环中选择一条边，强制删去，然后剩余的连通块可以看作一颗树，与没有上司的舞会是一样的。而对于整个连通块答案的统计可以选择被删去边两侧的点，依次枚举两者不被选择的情况。（保证不会冲突，如果枚举两个点被选取的情况，因为DP的无后效性，会出现A点被选取，但是B点因为一条边被删去，故同样的被选取的情况。）（只枚举不被选取的情况的正确性还可以有A，B中有边相连，可能出现的情况只有三种，（选A）（选B）（A，B都不要））</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> next,to;</span><br><span class="line">&#125;e[<span class="number">2</span>*MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN],cnt,val[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN],n;</span><br><span class="line"><span class="type">int</span> S,T,cut_edge[<span class="number">2</span>*MAXN],flag;</span><br><span class="line">LL f[MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="comment">// printf(&quot;%d %d\n&quot;,u,v);</span></span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            S=u;T=v;</span><br><span class="line">            cut_edge[i]=cut_edge[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>]=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> to=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa||cut_edge[i]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getans</span>(to,u);</span><br><span class="line">        f[u][<span class="number">0</span>]+=(LL)<span class="built_in">max</span>(f[to][<span class="number">0</span>],f[to][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>]+=(LL)f[to][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;val[i],&amp;tmp);</span><br><span class="line">        <span class="built_in">addedge</span>(i,tmp);</span><br><span class="line">        <span class="built_in">addedge</span>(tmp,i);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">getans</span>(S,<span class="number">0</span>);</span><br><span class="line">        LL temp = f[S][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">getans</span>(T,<span class="number">0</span>);</span><br><span class="line">        temp = <span class="built_in">max</span>(temp,f[T][<span class="number">0</span>]);</span><br><span class="line">        ans += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
        <tag>环</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>P2742题解</title>
    <url>/posts/41246cb9/</url>
    <content><![CDATA[<h2 id="暴力">暴力</h2>
<p> 对于求凸包的题，暴力的方法，从最左下的点开始，旋转一条边，找所有的点中最早与这条边重合的，这样做时间复杂度为<span
class="math inline">\(\Theta(nm)\)</span></p>
<h2 id="graham">Graham</h2>
<p> 考虑优化枚举顺序，使得每次不用重新判断每个点是否出现在这条线上，可以发现，一个凸包从左下角开始，逆时针依次枚举，路径上的点与左下角组成的直线角度逐渐增大，可以在选取了左下点后，以左下角与其他点组成的向量的角度大小作为排序基准，进行排序，以排序后的顺序作为枚举顺序。</p>
<p> 使用一个栈存下路径上的点，对于新进入的点<span
class="math inline">\(C\)</span>，假设此时栈顶的元素为<span
class="math inline">\(A\)</span>，栈顶下一个点为<span
class="math inline">\(B\)</span>，点<span
class="math inline">\(C\)</span>此时一定进入栈中，但是点<span
class="math inline">\(A\)</span>是否出栈，即点<span
class="math inline">\(A\)</span>是否在<span
class="math inline">\(CB\)</span>的连线之内，若在，那么<span
class="math inline">\(A\)</span>显然不再路径上，<span
class="math inline">\(A\)</span>出栈。下图是一个<span
class="math inline">\(A\)</span>在<span
class="math inline">\(CB\)</span>内的示意图。</p>
<figure>
<img src="image.png" alt="A在图中" />
<figcaption aria-hidden="true">A在图中</figcaption>
</figure>
<p>对于上面的情况，判断是否在凸包内可以采用向量叉乘，通过向量叉乘的<span
class="math inline">\(z\)</span>维的正负判断。叉乘计算方式为</p>
<p><span class="math display">\[
\begin{align*}
    \vec{a} \times \vec{b} &amp;= \left| \begin{matrix}
    \vec{i} &amp; \vec{j} &amp; \vec{k} \\
    \hline
    a_i &amp; a_j &amp; a_k\\
    b_i &amp; b_j &amp; b_k
\end{matrix}\right| \\
    &amp;= (a_j\cdot b_k-a_k\cdot b_j,-(a_i\cdot b_k-a_k\cdot
b_i),a_i\cdot b_j-a_j\cdot b_i)
\end{align*}
\]</span></p>
<p> 当<span class="math inline">\(z\)</span>轴均取0时，只保留值<span
class="math inline">\(a_i\cdot b_j-a_j\cdot b_i\)</span>，当<span
class="math inline">\(\vec{a}\)</span>沿逆时针方向转向<span
class="math inline">\(\vec{b}\)</span>时，<span
class="math inline">\(a_i\cdot b_j-a_j\cdot b_i &gt;
0\)</span>，可以由极坐标证明这个关系。</p>
<p> 那么判断条件变成计算<span
class="math inline">\(\vec{CA}\times\vec{CB}\)</span>，若值大于0，则证明点<span
class="math inline">\(A\)</span>需要出栈，若值等于0，则证明<span
class="math inline">\(\vec{CA}\)</span>和<span
class="math inline">\(\vec{CB}\)</span>共线，选择长度最长的那条边，才保证符合凸包的条件。</p>
<p> 需要注意这个过程需要一直进行，直到找到一个<span
class="math inline">\(\vec{CA}\)</span>和<span
class="math inline">\(\vec{CB}&lt;0\)</span>的点，再把点<span
class="math inline">\(C\)</span>插入栈中。</p>
<p> 最后得到答案需要加上栈中最后一个点到起始点的距离。</p>
<p> 排序效率为<span class="math inline">\(\Theta(n\log
n)\)</span>，扫描过程效率为<span
class="math inline">\(\Theta(n)\)</span></p>
<h2 id="andrew">Andrew</h2>
<p> Andrew算法使用不同的排序方法，按照<span
class="math inline">\(x\)</span>轴坐标的大小排序，判断过程一致，需要注意，Andrew算法从左到右只能枚举凸包的一半，还需要从结束点枚举回开始点。注意第二次枚举的时候通过栈记录路径时，出栈不能把前一半凸包（在上述枚举条件下，为下凸包）的路径清理掉。</p>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3377题解</title>
    <url>/posts/2fbd7ecf/</url>
    <content><![CDATA[<p> 这是一个基本的左偏树(可并堆)的模板，左偏树就是定义了距离<span
class="math inline">\(dist\)</span>，要求左子树的<span
class="math inline">\(dist\)</span>大于右子树的<span
class="math inline">\(dist\)</span>， <span
class="math inline">\(dist\)</span>定义为根到外点的距离，外点定义为一个子树的点，计算方式为边权之和，（可为层高差）</p>
<p> 并查集中对于根节点的删除，在给根节点删除之后，把根节点的父亲数组指向他的子节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lc, rc, dist, fa, val;</span><br><span class="line">&#125; tree[MAXN];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">合并操作</span></span><br><span class="line"><span class="comment">要求左子树的距离权值dist大于右子树的距离权值dist</span></span><br><span class="line"><span class="comment">当前树本身的权值dist大小记作右子树的权值+1</span></span><br><span class="line"><span class="comment">且这棵树本身符合堆的性质（此处为小根堆）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="comment">// 小根堆，根最小</span></span><br><span class="line">    <span class="keyword">if</span> (tree[x].val &gt; tree[y].val) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    tree[x].rc = <span class="built_in">merge</span>(tree[x].rc, y);</span><br><span class="line">    <span class="keyword">if</span> (tree[tree[x].lc].dist &lt; tree[tree[x].rc].dist) <span class="built_in">swap</span>(tree[x].lc, tree[x].rc);</span><br><span class="line">    tree[x].dist = tree[tree[x].rc].dist + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并查集路径压缩</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[x].fa == x ? x : tree[x].fa = <span class="built_in">find</span>(tree[x].fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tree[i].val);</span><br><span class="line">        tree[i].fa = i;</span><br><span class="line">        tree[i].lc = tree[i].rc = <span class="number">0</span>;</span><br><span class="line">        tree[i].dist = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span> (vis[x] || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 并查集找到两个点的根节点</span></span><br><span class="line">            tree[<span class="built_in">find</span>(x)].fa = tree[<span class="built_in">find</span>(y)].fa = <span class="built_in">merge</span>(<span class="built_in">find</span>(x), <span class="built_in">find</span>(y));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除操作</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> root = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree[root].val);</span><br><span class="line">            vis[root] = <span class="number">1</span>;</span><br><span class="line">            tree[root].fa = tree[tree[root].lc].fa = tree[tree[root].rc].fa = <span class="built_in">merge</span>(tree[root].lc, tree[root].rc);</span><br><span class="line">            tree[root].lc = tree[root].rc = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>可并堆(左偏树)</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P3805题解</title>
    <url>/posts/30b2f822/</url>
    <content><![CDATA[<p> 对于求回文串的要求，可以确定是从中间向两边扩散的算法，回文串可以分为偶回文串和奇回文串，为了方便，可以用不存在字符扩展整个回文串，使得偶回文串变成奇回文串，使得一个回文串一定存在一个回文中心。</p>
<p> Manacher的核心在于减少在计算回文串时每个字符被枚举的次数，假设分别以前<span
class="math inline">\(i-1\)</span>个字符作为回文中心，其最长回文长度已经求出，且回文串枚举最长枚举到最右侧<span
class="math inline">\(j\)</span>的位置，对应的回文中心为<span
class="math inline">\(center\)</span>，不妨设<span
class="math inline">\(j&gt;i\)</span>，那么此时，以<span
class="math inline">\(i\)</span>为中心的回文串长度<span
class="math inline">\(l_i\)</span>有一个下限</p>
<p><span class="math display">\[
    l_i = \min(l_{2*center-i},j-i)
\]</span></p>
<p>那么开始枚举就是从<span
class="math inline">\(i+l_i\)</span>之后的点开始判断是否构成以<span
class="math inline">\(i\)</span>为中心的回文串</p>
<p> 下面说明整体的复杂度为<span
class="math inline">\(\Theta(n)\)</span>，</p>
<p> 对于<span
class="math inline">\(i+l_i&lt;j\)</span>的情况，由于回文串的对称性，左右完全对称，那么以<span
class="math inline">\(i\)</span>为中心的回文串不可能再增加，因为如果增加的话，那么其对称点<span
class="math inline">\(2*center-i\)</span>的回文长度会增加，与事实不符。</p>
<p> 对于<span class="math inline">\(i+l_i=j\)</span>的情况，由于<span
class="math inline">\(j\)</span>右侧的情况未知，需要进行扩散判断是否能够构成回文串。</p>
<p> 可以看到每个点只会被枚举一次，故整体的复杂度为<span
class="math inline">\(\Theta(n)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">manacher</span> &#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 扩展字符串，使得不用区分奇偶回文串</span></span><br><span class="line">    <span class="function">string <span class="title">expandString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string result = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            result += s[i];</span><br><span class="line">            result += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    找到最长回文子串</span></span><br><span class="line"><span class="comment">    对于一个字符，如果它落在另一个回文串的内部，那么它的对称点也一定在这个回文串的内部，它的回文半径也一定等于它的对称点的回文半径且不会超过这个回文串的边界。</span></span><br><span class="line"><span class="comment">    通过这样的方法进行跳转，再判断之后的点是否符合回文串，可以在O(n)的时间复杂度内找到最长回文子串。因为每个点只枚举一次。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str = <span class="built_in">expandString</span>(s);</span><br><span class="line">        <span class="type">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">length</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxRight = <span class="number">0</span>, center = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ansCenter = <span class="number">0</span>, ansLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; maxRight) &#123;</span><br><span class="line">                length[i] = <span class="built_in">min</span>(length[<span class="number">2</span> * center - i], maxRight - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                length[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i - length[i] &gt;= <span class="number">0</span> &amp;&amp; i + length[i] &lt; n &amp;&amp; str[i - length[i]] == str[i + length[i]]) &#123;</span><br><span class="line">                length[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i + length[i] - <span class="number">1</span> &gt; maxRight) &#123;</span><br><span class="line">                maxRight = i + length[i] - <span class="number">1</span>;</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (length[i] &gt; ansLength) &#123;</span><br><span class="line">                ansLength = length[i];</span><br><span class="line">                ansCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于输出具体的字符串</span></span><br><span class="line">        <span class="comment">// string ans;</span></span><br><span class="line">        <span class="comment">// for(int i=ansCenter-(ansLength-1);i&lt;ansCenter+ansLength;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(str[i] == &#x27;#&#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//         continue;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     ans += str[i];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> ansLength - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>P3829题解</title>
    <url>/posts/b537952b/</url>
    <content><![CDATA[<p> 首先可以发现，如果半径为0，那么就是几个长方形之间求一个凸包，那么就是凸包的板，那么在半径不为0的情况下，首先根据样例，可以分析到对应的路径，如下图中绿色的线所示</p>
<figure>
<img src="image.png" alt="路径图" />
<figcaption aria-hidden="true">路径图</figcaption>
</figure>
<p>为了保证凸包，可以发现绿色的线与圆相切，此时考察一张信用卡中的4个圆心，观察所有的圆心组成的凸包，因为圆无法直接进行凸包运算，需要进行转化，猜测与圆心有关。那么如下图所示，可以得到圆心组成的凸包</p>
<figure>
<img src="image2.jpg" alt="圆心路径" />
<figcaption aria-hidden="true">圆心路径</figcaption>
</figure>
<p> 由分析可知，原凸包路径=圆心凸包路径+圆弧段长度，圆弧段的长度可以由下式算出</p>
<p><span class="math display">\[
    l_c = \theta*r = r*\sum_{i=1}^n \theta_i
\]</span></p>
<p>其中<span class="math inline">\(n\)</span>是圆弧对应的角<span
class="math inline">\(\theta_i\)</span>的个数，也是凸包内角<span
class="math inline">\(\alpha_i\)</span>个数，由几何关系可以知道，<span
class="math inline">\(\theta_i\)</span>和<span
class="math inline">\(\alpha_i\)</span>之间有如下的对应关系</p>
<p><span class="math display">\[
    \theta_i = \pi - \alpha_i
\]</span></p>
<p>那么带入圆弧长度的公式就有</p>
<p><span class="math display">\[
    l_c = r*\sum_{i=1}^n \theta_i = r*\sum_{i=1}^n (\pi-\alpha_i) = r *
(n\pi-\sum_{i=1}^n\alpha_i)\\
    = r*(n\pi-(n-2)\pi ) = 2\pi r
\]</span></p>
<p>故圆弧部分的长度固定，那么这道题就转换为求圆心组成的凸包的长度加上一个圆的周长</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">double</span> a, b, r, X[MAXN &lt;&lt; <span class="number">2</span>], Y[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> adx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">-0.5</span>&#125;, ady[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graham</span> &#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, pos, ans_stack[MAXN], ans_top;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">double</span> x, y;</span><br><span class="line">        node <span class="keyword">operator</span>-(node a) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;x - a.x, y - a.y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重载为叉乘运算</span></span><br><span class="line">        <span class="type">double</span> <span class="keyword">operator</span>*(node a) &#123;</span><br><span class="line">            <span class="keyword">return</span> x * a.y - y * a.x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重载为点积运算</span></span><br><span class="line">        <span class="type">double</span> <span class="keyword">operator</span>^(node a) &#123;</span><br><span class="line">            <span class="keyword">return</span> x * a.x + y * a.y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; node_list[MAXN], stap;</span><br><span class="line">    <span class="type">double</span> ans, eps = <span class="number">1e-7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(node i, node j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((i - j) ^ (i - j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    计算两个向量的叉乘</span></span><br><span class="line"><span class="comment">    如果结果小于0，说明向量a在向量b的逆时针方向，返回0</span></span><br><span class="line"><span class="comment">    如果结果大于0，说明向量a在向量b的顺时针方向，返回1</span></span><br><span class="line"><span class="comment">    对于等于0的情况，说明向量a和向量b共线,还需要判断两个向量的距离，若b距离原点更近，则返回1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> tmp = a * b;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; -eps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(tmp) &lt; eps) &#123;</span><br><span class="line">            <span class="type">double</span> dis1 = <span class="built_in">dist</span>(a, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;), dis2 = <span class="built_in">dist</span>(b, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (dis2 - dis1 &gt; eps) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断向量(新来的点-&gt;栈顶组成元素)是否在向量(新来的点-&gt;栈顶下一个元素)的顺时针方向</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">checkvalida</span><span class="params">(node a, node b, node c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(c - a, c - b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graham</span>() &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        ans_top = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Graham</span>(<span class="type">int</span> n, <span class="type">double</span> *x, <span class="type">double</span> *y) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        ans_top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            node_list[i].x = x[i];</span><br><span class="line">            node_list[i].y = y[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选择初始点，当枚举边采用逆时针旋转的方法时，选择最下方的点，当y值相同的时候，选择最左边的点</span></span><br><span class="line">        stap.y = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node_list[i].y &lt; stap.y || (node_list[i].y == stap.y &amp;&amp; node_list[i].x &lt; stap.x)) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                stap = node_list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">swap</span>(node_list[<span class="number">1</span>], node_list[pos]);</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(node_list + <span class="number">2</span>, node_list + n + <span class="number">1</span>,</span><br><span class="line">                  <span class="comment">// 按照与初始点的极角排序</span></span><br><span class="line">                  [&amp;](node a, node b) &#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="built_in">cmp</span>(a - stap, b - stap);</span><br><span class="line">                  &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断向量(新来的点-&gt;栈顶组成元素)是否在向量(新来的点-&gt;栈顶下一个元素)的顺时针方向即叉乘大于0，如果在，那么栈顶元素出栈，一定不会是最优解。</span></span><br><span class="line">            <span class="keyword">while</span> (ans_top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">checkvalida</span>(node_list[ans_stack[ans_top]], node_list[ans_stack[ans_top - <span class="number">1</span>]], node_list[i])) ans_top--;</span><br><span class="line">            ans_stack[++ans_top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= ans_top; i++) &#123;</span><br><span class="line">            ans += <span class="built_in">dist</span>(node_list[ans_stack[i]], node_list[ans_stack[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="built_in">dist</span>(node_list[ans_stack[<span class="number">1</span>]], node_list[ans_stack[ans_top]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> theta, <span class="type">int</span> pos, <span class="type">double</span> cx, <span class="type">double</span> cy)</span> </span>&#123;</span><br><span class="line">    X[pos] = cx + x * <span class="built_in">cos</span>(theta) - y * <span class="built_in">sin</span>(theta);</span><br><span class="line">    Y[pos] = cy + x * <span class="built_in">sin</span>(theta) + y * <span class="built_in">cos</span>(theta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;a, &amp;b, &amp;r);</span><br><span class="line">    std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">double</span> cx, cy, theta;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;cx, &amp;cy, &amp;theta);</span><br><span class="line">        <span class="comment">// 计算旋转后的圆心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; k++)</span><br><span class="line">            <span class="built_in">rotate</span>((a - <span class="number">2</span> * r) * adx[k], (b - <span class="number">2</span> * r) * ady[k], theta, (i - <span class="number">1</span>) * <span class="number">4</span> + k, cx, cy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Graham <span class="title">graham</span><span class="params">(N * <span class="number">4</span>, X, Y)</span></span>;</span><br><span class="line">    <span class="type">double</span> ans = graham.<span class="built_in">solve</span>() + <span class="number">2</span> * <span class="number">3.14159265358979323846</span> * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3917题解</title>
    <url>/posts/7cfcfdd6/</url>
    <content><![CDATA[<p>​ 这道题使用的是异或进行操作，异或运算也可以进行前缀和操作，而异或和的位之间具有独立性，两个二进制位之间的异或运算相互互不影响。</p>
<p>​ 这道题求<span
class="math inline">\(N\)</span>长序列的所有异或子序列之和，哪怕使用前缀异或和，其复杂度也是<span
class="math inline">\(\Theta(N^2)\)</span>，难以接受，故不能直接暴力计算其异或子序列之和，考虑计算不同序列的个数直接计算。可以将每个序列考虑拆成2的幂次相加的形式，即2进制表达。考虑异或操作的独立性，分别对于每一个二进制位统计其前缀和，单独的01序列方便直接判断其是否产生贡献，那么对于所有01序列，那么其产生的贡献次数为<span
class="math inline">\(num_1*num_0\)</span>，最终统计答案的时候，使用贡献次数乘上此时的系数即2的幂次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll N, A[MAXN], S[MAXN][<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;A[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++)</span><br><span class="line">            S[i][k] = S[i - <span class="number">1</span>][k] ^ ((A[i] &gt;&gt; k) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">32</span>; k++) &#123;</span><br><span class="line">        ll num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i][k])</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += num * (N - num + <span class="number">1</span>) * (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>P4317题解</title>
    <url>/posts/b0e6c31/</url>
    <content><![CDATA[<p> 要求计算<span
class="math inline">\(\prod_{i=1}^{N}sum(i)\)</span>的值，N足够大，<span
class="math inline">\(sum(i)\)</span>是二进制表达中1的个数。可以打标出<span
class="math inline">\(sum(i)\)</span>的个数，那么从1到8的<span
class="math inline">\(sum\)</span>值对应如下</p>
<table>
<thead>
<tr class="header">
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(sum(i)\)</span></td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>可以发现<span
class="math inline">\(sum(i)\)</span>的值足够小，不超过其二进制位数的大小，故同样大小的<span
class="math inline">\(sum(i)\)</span>会重复出现，因为目标式子是求积，故可以把目标式子改写为
<span class="math display">\[
\prod_{i=1}^{N}sum(i) = \prod_{j=1}^{tot}j^{G_j}
\]</span> 其中<span class="math inline">\(j\)</span>为<span
class="math inline">\(sum(i)\)</span>可能出现的值，<span
class="math inline">\(G_j\)</span>对应着<span
class="math inline">\(sum(i)=j\)</span>出现的次数。那么原题转化为求解<span
class="math inline">\(G_j\)</span>，即对应不同值的<span
class="math inline">\(sum(i)\)</span>出现次数。可以想到这是一个数位DP。</p>
<p> 选取第一维度<span
class="math inline">\(i\)</span>为当前进行到了二进制表达下的第<span
class="math inline">\(i\)</span>位，因为是对二进制位进行操作，所以不需要考虑此时在最高位的数字是什么，可以省下一维。故第二维<span
class="math inline">\(j\)</span>表示当前统计的是<span
class="math inline">\(sum(x)=j\)</span>的个数。整体状态<span
class="math inline">\(f[i][j]\)</span>表示，当二进制最高位为<span
class="math inline">\(i\)</span>时，满足<span
class="math inline">\(sum(x)=j\)</span>的<span
class="math inline">\(x\)</span>的数量。</p>
<p> 那么可以知道计算<span class="math inline">\(f\)</span>的转移方程为
<span class="math display">\[
f[i][j] = \sum_{k=j-1}^{i-1}f[k][j-1]
\]</span>  因为<span
class="math inline">\(f[i][j]\)</span>表示当前的二进制位中有<span
class="math inline">\(j\)</span>个1且 最高位的1在第<span
class="math inline">\(i\)</span>位上，那么其个数应该由二进制表达中有<span
class="math inline">\(j-1\)</span>个1的状态转移而来，因为此时确定了最高位为<span
class="math inline">\(i\)</span>那么枚举第一维的上限应该就是<span
class="math inline">\(i-1\)</span>，所以应该枚举最高位可能出现的位置，并将对应的值相加作为<span
class="math inline">\(f[i][j]\)</span>的值。</p>
<p> 对于答案的统计，首先明确，分开统计不同<span
class="math inline">\(sum(x)\)</span>取值，依次枚举，不妨假设需要统计<span
class="math inline">\(sum(x)=j\)</span>， 开始依次枚举<span
class="math inline">\(j\)</span>。接下来，对于给出的上限<span
class="math inline">\(N\)</span>，从它的二进制最高位到最低位开始枚举（从高位到低位枚举，保证统计的内容来源一定时小于<span
class="math inline">\(N\)</span>的数，这一点与比大小的过程相同）</p>
<p> 取<span class="math inline">\(N\)</span>的二进制表达为<span
class="math inline">\(a_1,a_2,a_3,\dots,a_n\)</span>，</p>
<ul>
<li>如果此时<span
class="math inline">\(a_i=1\)</span>，那么计算当第<span
class="math inline">\(i\)</span>位为0时，剩余位数产生的贡献即<span
class="math inline">\(f[i-1][tmp]\)</span>，其中<span
class="math inline">\(tmp\)</span>表示为统计目标值<span
class="math inline">\(j\)</span>减去从<span
class="math inline">\(n\)</span>的二进制表达中第<span
class="math inline">\(i\)</span>位到<span
class="math inline">\(n\)</span>位中的已确定的1的数量，表示为<span
class="math inline">\(tmp = j -
num_1\)</span>，如果发现现在计算完成后，计算上当前位置上的1后即<span
class="math inline">\(num_1+1\)</span>，大于目标<span
class="math inline">\(j\)</span>，那么不再进行枚举，因为<span
class="math inline">\(num_1+1&gt;j\)</span>说明在确定完这一位之后，无论后续怎么枚举，含有的1个数总会多于目标<span
class="math inline">\(j\)</span>，故跳出循环，开始枚举下一个<span
class="math inline">\(j\)</span>.</li>
<li>如果此时<span class="math inline">\(a_i=0\)</span>，那么跳过。</li>
</ul>
<p>计算完成后继续枚举<span
class="math inline">\(a_{i-1}\)</span>位。在完成枚举到最低的二进制位之后，那么如果目标位数<span
class="math inline">\(j\)</span>与<span
class="math inline">\(N\)</span>本身含有的1的个数相同，即<span
class="math inline">\(tmp=j-num_1=0\)</span>时，<span
class="math inline">\(N\)</span>本身会对目标<span
class="math inline">\(j\)</span>产生贡献，需要最后补上本身带来的贡献。</p>
<p> 最终对于输出的答案，按需要计算幂次即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 10000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 55</span></span><br><span class="line">ll dp[MAXN][MAXN];</span><br><span class="line">ll G[MAXN];</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j - <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                dp[i][j] += dp[k][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % MOD;</span><br><span class="line">        a = a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        a[++tot] = n % <span class="number">2</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tot; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = tmp; k &lt; i; k++)</span><br><span class="line">                    G[j] += dp[k][tmp];</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                tmp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; tmp == <span class="number">0</span>) G[j] += dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        ans = ans * <span class="built_in">quickpow</span>(i, G[i]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P4756题解</title>
    <url>/posts/74df3873/</url>
    <content><![CDATA[<p> 题目要求<span
class="math inline">\(\max(\sum_{k=i}^{j}|a_k|)\)</span>，此时记前<span
class="math inline">\(i\)</span>位的前缀和为<span
class="math inline">\(S_i\)</span>，那么可以可以写成<span
class="math inline">\(\max(|S_i-S_j|)\)</span>，因为有绝对值，所以就成了找到最大的前缀和和最小的前缀和。那么每一次查询对应的<span
class="math inline">\(x\)</span>，就需要去找一次序列最大值和最小值，设查询次数为<span
class="math inline">\(T\)</span>，那么此时的复杂度应该为<span
class="math inline">\(\Theta(TN)\)</span>，复杂度难以接受，故考虑优化这个过程。</p>
<p> 题目要求的是每一次都是在初始序列上加上一个值<span
class="math inline">\(x_i\)</span>，只是<span
class="math inline">\(x_i\)</span>的大小与上一次查询输出的结果相关，故是强制在线的一个过程。</p>
<p> 那么对于在<span
class="math inline">\(i\)</span>位处的前缀和在加上了<span
class="math inline">\(x\)</span>之后，其值变成<span
class="math inline">\(i\times x +
S_i\)</span>事实上，对于每个点来说，每一次修改<span
class="math inline">\(x\)</span>后，可以用上式得到此时这个点处的前缀和，因为<span
class="math inline">\(x\)</span>不确定，那么可以看出，每个点处实际维护了一条直线，直线方程为</p>
<p><span class="math display">\[
y = i\times x+S_i
\]</span></p>
<p> 那么这道题转化为每次查询找到对应带入<span
class="math inline">\(x\)</span>后最小的直线，和最大的直线，并求对应<span
class="math inline">\(y\)</span>相减之后的结果。因为一直采用的是初始序列那么说明直线不变，是一个静态的过程，（不用采用李超线段树这种功能更为强大的数据结构）可以采用凸包的知识，维护一个上凸包来维护各个区间上的能够取最大值的直线，同理，维护一个下凸包来维护各个区间上的能够取得最小值的直线，那么每次查询就变成了找到对应的<span
class="math inline">\(x\)</span>在具体的哪条直线上，求出对应的值，并相减就是答案，那么找<span
class="math inline">\(x\)</span>的过程可以使用二分法，那么整体的效率就是<span
class="math inline">\(\Theta(T\log N)\)</span></p>
<p> 相对于普通的凸包板，此时给定的是直线而非线上的点，那么需要修改整个过程，就不用选点和对点进行排序，在这道题中按照斜率从小到大的过程对直线进行枚举，那么就是按照从1到<span
class="math inline">\(N\)</span>依次进行，同样维护一个栈，栈中存合法的直线的编号。</p>
<p> 那么以维护最大值为例，判断栈顶直线是否出栈的条件在于当前的直线与栈顶直线的交点是否在当前直线与栈顶下一个元素的直线右侧，若在，那么不出栈，若不在那么出栈。对于输入的<span
class="math inline">\(x\)</span>，使用二分法找到对应在那条直线上，求出对应解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> ans_max[MAXN], max_top;</span><br><span class="line"><span class="type">int</span> ans_min[MAXN], min_top;</span><br><span class="line">ll s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graham</span> &#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">calcnode</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)(s[b] - s[a]) / (a - b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        max_top = <span class="number">0</span>;</span><br><span class="line">        min_top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (max_top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">calcnode</span>(ans_max[max_top - <span class="number">1</span>], i) &gt;= <span class="built_in">calcnode</span>(ans_max[max_top], i)) max_top--;</span><br><span class="line">            ans_max[++max_top] = i;</span><br><span class="line">            <span class="keyword">while</span> (min_top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">calcnode</span>(ans_min[min_top - <span class="number">1</span>], i) &lt;= <span class="built_in">calcnode</span>(ans_min[min_top], i)) min_top--;</span><br><span class="line">            ans_min[++min_top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, tmp; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tmp);</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">solve</span><span class="params">(ll x, ll pre)</span> </span>&#123;</span><br><span class="line">        x = (x + pre) % (<span class="number">4</span> * n + <span class="number">1</span>) - <span class="number">2</span> * n;</span><br><span class="line">        <span class="type">int</span> mxl = <span class="number">1</span>, mxr = max_top;</span><br><span class="line">        <span class="keyword">while</span> (mxl &lt; mxr) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (mxl + mxr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">calcnode</span>(ans_max[mid], ans_max[mid + <span class="number">1</span>]) &gt; (<span class="type">double</span>)x)</span><br><span class="line">                mxr = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calcnode</span>(ans_max[mid], ans_max[mid + <span class="number">1</span>]) == x) &#123;</span><br><span class="line">                mxl = mid;</span><br><span class="line">                mxr = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                mxl = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mnl = <span class="number">1</span>, mnr = min_top;</span><br><span class="line">        <span class="keyword">while</span> (mnl &lt; mnr) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (mnl + mnr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">calcnode</span>(ans_min[mid], ans_min[mid + <span class="number">1</span>]) &lt; (<span class="type">double</span>)x)</span><br><span class="line">                mnr = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calcnode</span>(ans_min[mid], ans_min[mid + <span class="number">1</span>]) == x) &#123;</span><br><span class="line">                mnl = mid;</span><br><span class="line">                mnr = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                mnl = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ll)(ans_max[mxl] - ans_min[mnl]) * x + s[ans_max[mxl]] - s[ans_min[mnl]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graham graham;</span><br><span class="line">    graham.<span class="built_in">get_info</span>();</span><br><span class="line">    ll pre = <span class="number">0</span>, x;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, pre = graham.<span class="built_in">solve</span>(x, pre));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>凸包</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P5049题解</title>
    <url>/posts/c59e4ef3/</url>
    <content><![CDATA[<p> 对于按照题目给出的条件，可以分为两种不同的情况去讨论，第一种是<span
class="math inline">\(m=n-1\)</span>即构成一颗树的情况，第二种情况下<span
class="math inline">\(m=n\)</span>，整张图有且只有一个简单的环，除环上所有的点外，其余点构成一棵树。</p>
<p> 对于第一种情况，根据题目要求，每一次向前走只能走到一个之前没走到的位置，或者沿着原路返回，并要求遍历完所有的点，那么这个遍历顺序就和树的遍历顺序一致，树的遍历过程符合上述的要求。要求最小字典序，可以知道这是一个贪心的过程。那么在遍历树的时候，优先选择编号小的子节点进行遍历，最终得到的遍历顺序就是最小的。</p>
<p> 对于第二种情况，对于不在环上的点，与第一种情况相同。对于在环上的点，按照出边点的大小从小到大依次枚举，只讨论下一个点仍然在环上的情况。</p>
<p> 需要明确，在一个环上，最多只能回溯一次，即回溯一次后，剩下的点与第一种情况相同。即在环上回溯的操作相当于删去了一条边，而对于只有一个环的情况，那么只可能删去一条边即回溯一次。</p>
<p> 对于如果下一个点仍然在环上，如果在这个点处需要进行回溯，那么需要这个点的出边中，所有不在环上的相连点已经访问过了，即如果按照从小到大的顺序排序依次访问，且这个环上没有其他点回溯过，否则不能访问所有的点，条件转化为，目标点仍在环上的边是否是最后一条边且这个环从未回溯过。那么是否选择回溯，看回溯后的第一个访问的节点和不回溯访问的环上点谁的标号大，如果回溯后的结果更佳，那么选择回溯。如果不能回溯，即有目标点比环上点的标号大的边，即除了目标点为环上的边之外，还有边没有访问过，那么就更新回溯后第一次访问的点值改为目标点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125; e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, to;</span><br><span class="line">&#125; edgenode[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN], ecnt, n, m;</span><br><span class="line"><span class="type">int</span> ans[MAXN], nowtop;</span><br><span class="line"><span class="type">int</span> pre[MAXN], lsbranch;</span><br><span class="line"><span class="type">bool</span> isring[MAXN], flag, retrivflag, vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++ecnt].to = v;</span><br><span class="line">    e[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    ans[++nowtop] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.to &gt; b.to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ring</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pre[u]) &#123;</span><br><span class="line">        <span class="keyword">while</span> (fa != u) &#123;</span><br><span class="line">            isring[fa] = <span class="literal">true</span>;</span><br><span class="line">            fa = pre[fa];</span><br><span class="line">        &#125;</span><br><span class="line">        isring[u] = <span class="literal">true</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre[u] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa || flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">get_ring</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsring</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    ans[++nowtop] = u;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isring[u] &amp;&amp; !retrivflag) &#123;</span><br><span class="line">        <span class="type">bool</span> tmpflag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (isring[v]) &#123;</span><br><span class="line">                <span class="type">int</span> j = e[i].nxt;</span><br><span class="line">                <span class="keyword">while</span> (vis[e[j].to]) j = e[j].nxt;</span><br><span class="line">                <span class="keyword">if</span> (j) &#123;</span><br><span class="line">                    lsbranch = e[j].to;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; lsbranch) &#123;</span><br><span class="line">                    retrivflag = <span class="literal">true</span>;</span><br><span class="line">                    tmpflag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (isring[v] &amp;&amp; tmpflag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfsring</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfsring</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        edgenode[i].to = v;</span><br><span class="line">        edgenode[i].u = u;</span><br><span class="line">        edgenode[i + m].to = u;</span><br><span class="line">        edgenode[i + m].u = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edgenode + <span class="number">1</span>, edgenode + <span class="number">2</span> * m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++) &#123;</span><br><span class="line">        <span class="built_in">addEdge</span>(edgenode[i].u, edgenode[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_ring</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    lsbranch = <span class="number">2</span> * n;</span><br><span class="line">    <span class="built_in">dfsring</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>环</tag>
        <tag>图论</tag>
        <tag>树的遍历</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P5197题解</title>
    <url>/posts/19df343c/</url>
    <content><![CDATA[<p> 对于这道题，题目需要具体的颜色数目，而不需要颜色是如何分配的，那么需要计算的就不是颜色的具体方案，而是颜色的个数。</p>
<p> 对于题目中的要求，对于其中的某一个点来说，以这个点作为根，可以发现，至少需要它的出度+1个颜色来进行填色。下面说明，这道题在树的情况下，其需要的最少颜色就是所有点的出度+1中的最大值</p>
<p> 首先可以发现图中构成一棵树，故无法出现如下图所示的图形</p>
<figure>
<img src="image.png" alt="示例图片" />
<figcaption aria-hidden="true">示例图片</figcaption>
</figure>
<p>在上图中，可以注意到统计节点1得到的答案为3，但是仅用三种颜色，无论如何选择，节点4都无法用这三种颜色进行填色。</p>
<p> 考虑在树中的情况，假设现在得到了树的最大出度+1为<span
class="math inline">\(ans\)</span>，且从上到下分配颜色，对于一个未分配颜色的节点<span
class="math inline">\(x\)</span>，其首先受到的限制为其父节点<span
class="math inline">\(fa[x]\)</span>和父节点的父节点<span
class="math inline">\(fa[fa[x]]\)</span>的颜色影响。那么可以分情况讨论</p>
<ol type="1">
<li>不存在<span class="math inline">\(fa[fa[x]]\)</span>节点</li>
<li>存在<span class="math inline">\(fa[fa[x]]\)</span>节点</li>
</ol>
<p> 首先对于不存在<span
class="math inline">\(fa[fa[x]]\)</span>的情况，那么对于节点<span
class="math inline">\(x\)</span>，其一共可以有<span
class="math inline">\(ans-1\)</span>种选择颜色选择，而有<span
class="math inline">\(ans\geq 2\)</span>，那么显然可以有合法的方案。</p>
<p> 对于<span
class="math inline">\(fa[fa[x]]\)</span>存在，那么对于对于节点<span
class="math inline">\(x\)</span>，其能够选择的颜色方案就有<span
class="math inline">\(ans-2\)</span>个，在存在<span
class="math inline">\(fa[fa[x]]\)</span>的情况下，<span
class="math inline">\(fa[x]\)</span>能够产生至少3的贡献，即此时<span
class="math inline">\(ans\geq 3\)</span>，那么显然对于该节点<span
class="math inline">\(x\)</span>，显然有合法的选择方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> vis[MAXN], ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        vis[u]++;</span><br><span class="line">        vis[v]++;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(vis[u], vis[v]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>P7521题解</title>
    <url>/posts/7e7c9c61/</url>
    <content><![CDATA[<p> 这道题要求求一个序列中找到三个数<span
class="math inline">\(a_i,a_j,a_k\)</span>，且<span
class="math inline">\(i,j,k\)</span>互不相同，满足<span
class="math inline">\((a_i+a_j)\% a_k\)</span>的值最大。</p>
<p> 首先想到暴力解法，首先枚举模数<span
class="math inline">\(a_k\)</span>,接着进行排列开始枚举<span
class="math inline">\(a_i,a_j\)</span>，这样的方法的时间复杂度为<span
class="math inline">\(\Theta(n^3)\)</span>，找<span
class="math inline">\(a_i, a_j\)</span>的过程可以进行优化。</p>
<p> 对于公式有 <span class="math display">\[
    (a_i+a_j)\%a_k=(a_i\%a_k+a_j\%a_k)\%a_k
\]</span>
a序列自身的顺序并不影响最后的结果，故可以把a序列进行排序，对于每一次枚举，先对所有的除模数之外的点取模后形成新的序列b后进行排序。</p>
<p> 两数相加之中，首先为了不重复枚举组合，不妨设<span
class="math inline">\(b_i\leq b_j\)</span>,即在排序后有序号下标<span
class="math inline">\(i&lt;j\)</span>，对于这样一个数<span
class="math inline">\(b_i\)</span>，有<span
class="math inline">\(b_i+b_j\leq2*a_k\)</span>，现在总共可能出现两种不同的情况</p>
<ol type="1">
<li><span class="math inline">\(b_i+b_j&lt;a_k\)</span></li>
<li><span class="math inline">\(b_i+b_j\geq a_k\)</span></li>
</ol>
<p> 因为<span class="math inline">\(b\)</span>数组取模后形成，有<span
class="math inline">\(\forall i\quad 0\leq
b_i&lt;a_k\)</span>，对于情况2来说<span
class="math inline">\((b_i+b_j)\%a_k\)</span>的值一定会小于<span
class="math inline">\(b_j\)</span>，而情况1下，<span
class="math inline">\((b_i+b_j)\%a_k\)</span>的值一定大于<span
class="math inline">\(b_j\)</span>，所以寻找的策略可以确定为优先去找到最大的使得<span
class="math inline">\((b_i+b_j)&lt;a_k\)</span>的<span
class="math inline">\(b_i\)</span>，当无法找到这样的<span
class="math inline">\(b_i\)</span>时，那么使得<span
class="math inline">\(b_i\)</span>尽可能的大，即<span
class="math inline">\(i=j-1\)</span>，计算答案。</p>
<p> 考虑进一步优化这个策略，可以从大到小开始枚举<span
class="math inline">\(b_j\)</span>，当上一个<span
class="math inline">\(b_j\)</span>对应的<span
class="math inline">\(b_i\)</span>值找到后，一共只有两种情况</p>
<ol type="1">
<li><span class="math inline">\(i&lt;j\)</span></li>
<li><span class="math inline">\(i\)</span>不存在，强制选择<span
class="math inline">\(b_{j-1}\)</span>作为<span
class="math inline">\(b_i\)</span>计算答案</li>
</ol>
<p>计<span class="math inline">\(t\)</span>为第一个使得<span
class="math inline">\((b_i+b_j)\geq a_k\)</span>的<span
class="math inline">\(b_i\)</span>的下标，显然有<span
class="math inline">\(t\leq j\)</span>，对于第一种情况，<span
class="math inline">\(t&gt;1\)</span>，对于第二种情况，<span
class="math inline">\(t=1\)</span>。</p>
<p> 设<span class="math inline">\(b_j\)</span>对于得到的下标为<span
class="math inline">\(t_j\)</span>，那么对于<span
class="math inline">\(b_{j-1}\)</span>来说，因为<span
class="math inline">\(b_{j-1}&lt;b_j\)</span>那么在<span
class="math inline">\(t_j\)</span>之前的数一定满足条件，即<span
class="math inline">\(\forall i&lt;t_j,\quad
b_i+b_{j-1}&lt;a_k\)</span>，那么对于<span
class="math inline">\(b_{j-1}\)</span>来说，只需要从<span
class="math inline">\(t_j\)</span>开始验证两数之和是否小于<span
class="math inline">\(a_k\)</span>，直到找到一个大于<span
class="math inline">\(a_k\)</span>的组合或者枚举到<span
class="math inline">\(j-1\)</span>这个点，即表示<span
class="math inline">\(j-1\)</span>之前的点均满足条件。</p>
<p> 如果这样的过程中，如果一开始<span
class="math inline">\(j-1&lt;t_j\)</span>，这种情况证明<span
class="math inline">\(b_{j-1}+b_j&lt;a_k\)</span>，那么有<span
class="math inline">\(b_{j-2}+b_{j-1}&lt;b_{j-1}+b_j&lt;a_k\)</span>,故可以直接将<span
class="math inline">\(t_{j-1}\)</span>赋值为<span
class="math inline">\(j-1\)</span></p>
<p> 具体枚举每个数对应的<span
class="math inline">\(b_i\)</span>的运行次数不确定，与自身的大小和模数大小相关，但是整体来说，每个数在同一个模数的情况下，只会被计算一次。故将暴力枚举<span
class="math inline">\(\Theta(n^2)\)</span>的复杂度将为了<span
class="math inline">\(\Theta(n)\)</span></p>
<p> 这样的策略可以使得当确定了<span
class="math inline">\(a_k\)</span>后找<span
class="math inline">\(a_i,a_j\)</span>的过程的复杂度变为<span
class="math inline">\(\Theta(n\log
n)\)</span>，那么整体的复杂度来到了<span
class="math inline">\(\Theta(n^2\log n)\)</span>，</p>
<p> 考虑枚举模数的顺序，考虑从大到小枚举，模数越大，两数之和才可能越大，在模数大的情况下取得答案的可能性大于模数小的情况下。可以有如下两个剪枝</p>
<ul>
<li>相同值只枚举一次，因为模数相同的情况下，形成的<span
class="math inline">\(b\)</span>相同</li>
<li>如果之前得到的答案已经大于当前模数-1，那么之后得到的和不可能比之前的答案更大，直接跳出并输出答案。</li>
</ul>
<p> 按照上述的剪枝，最后可以在时间复杂度要求内得到答案，那么显然一定是第二个剪枝使得时间复杂度可以接受，下面说明在第二个剪枝下，算法的时间复杂度降为<span
class="math inline">\(\Theta(n\log n\log V)\)</span>，其中<span
class="math inline">\(V\)</span>是数组中数最大可能的上限，在这种情况下<span
class="math inline">\(\Theta(\log
V)\)</span>可以看作是常数，算法降为<span
class="math inline">\(\Theta(n\log n)\)</span></p>
<p> 设此时选取的模数为<span
class="math inline">\(a_k\)</span>，在第<span
class="math inline">\(k\)</span>位到第<span
class="math inline">\(n\)</span>的数完成了枚举，之前得到的答案为<span
class="math inline">\(ans\)</span>，不妨设 <span class="math display">\[
    a_1\leq a_2\leq\dots\leq ans\leq a_k\leq a_{k+1}\leq\dots\leq a_n
\]</span> 那么显然有如下不等式成立 <span class="math display">\[
    \forall i\in[k,n-2],\quad ans\geq (a_i+a_{i+1})\%a_{i+2}
\]</span>
因为不等式右侧为答案的一种组成且不一定就是最优解。可以将不等式改写成
<span class="math display">\[
    \forall i\in[k,n-2],\quad ans\geq a_i+a_{i+1}-a_{i+2}
\]</span> 进一步改写不等式，可以变成 <span class="math display">\[
    \forall i\in[k,n-2],\quad (a_{i+2}-ans)\geq (a_i-ans)+(a_{i+1}-ans)
\]</span> 不妨设<span
class="math inline">\(f_n=a_n-ans\)</span>，那么上式可以写成 <span
class="math display">\[
    \forall i\in[k,n-2],\quad f_{i+2}\geq f_{i+1}+f_i
\]</span> 那么说明在最极端的情况下，大于<span
class="math inline">\(ans\)</span>的值构成一个斐波那契数列，斐波那契数列成指数级增长，通项公式为<span
class="math inline">\(((\frac{\sqrt{5}+1}{2})^n+(\frac{\sqrt{5}-1}{2})^n)\)</span>，而最大值<span
class="math inline">\(a_n\)</span>不超过1e8，那么<span
class="math inline">\(ans\)</span>落在从后向前数<span
class="math inline">\(log(1e8)\)</span>级别的位置，故只用枚举的效率是常数级。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, a[MAXN], b[MAXN], ans_max;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tmp = n; tmp &gt;= <span class="number">1</span>; tmp--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans_max &gt; a[tmp] - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mp[a[tmp]] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[a[tmp]] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> lenb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == tmp) <span class="keyword">continue</span>;</span><br><span class="line">            b[++lenb] = a[i] % a[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b + <span class="number">1</span>, b + lenb + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = lenb, l = <span class="number">1</span>; r &gt;= <span class="number">1</span>; r--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">                l = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; b[r] + b[l] &lt; a[tmp]) l++;</span><br><span class="line">            <span class="keyword">if</span> (l - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans_max = <span class="built_in">max</span>(ans_max, b[l - <span class="number">1</span>] + b[r]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans_max = <span class="built_in">max</span>(ans_max, (b[r - <span class="number">1</span>] + b[r]) % a[tmp]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans_max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>剪枝</tag>
        <tag>暴力</tag>
        <tag>取模</tag>
      </tags>
  </entry>
</search>
